{
    "version": "https://jsonfeed.org/version/1",
    "title": "一个小萌新的进阶之路 • All posts by \"容器\" category",
    "description": "",
    "home_page_url": "https://hahayixiao2.github.io",
    "items": [
        {
            "id": "https://hahayixiao2.github.io/computer-science/container/Docker%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BAlpine/dockeralpine/",
            "url": "https://hahayixiao2.github.io/computer-science/container/Docker%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BAlpine/dockeralpine/",
            "title": "dockeralpine笔记",
            "date_published": "2022-05-04T10:15:48.000Z",
            "content_html": "<h1 id=\"docker操作系统之alpine\"><a class=\"markdownIt-Anchor\" href=\"#docker操作系统之alpine\">#</a> Docker 操作系统之 Alpine</h1>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>这阵子我发现只要带着 alpine 前缀的镜像，相比于其它的镜像，体积都相对较小，例如下面这些</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>java:alpine</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>nginx:alpine</pre></td></tr></table></figure><p>后面通过了解，发现了其实这些 java 镜像，或者 nginx 镜像都依赖于某个 linux 操作系统，我们常见的操作系统有  ubuntu、centos、debian。而这个 alpine 其实也是一个新的操作系统。但是它比其它的操作系统而言，体积更小，所以在他们的基础之上做的镜像，体积也会更小，常见的 linux 操作系统体积大小，如下所示</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>REPOSITORY          TAG           IMAGE ID          VIRTUAL SIZE</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>alpine              latest        4e38e38c8ce0      <span class=\"token number\">4.799</span> MB</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>debian              latest        4d6ce913b130      <span class=\"token number\">84.98</span> MB</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>ubuntu              latest        b39b81afc8ca      <span class=\"token number\">188.3</span> MB</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>centos              latest        8efe422e6104      <span class=\"token number\">210</span> MB</pre></td></tr></table></figure><p>我们也就发现了 alpine 的大小远远小于 其它的操作系统，因此制作出来的镜像大小也远远小于其它的</p>\n<h2 id=\"alpine操作系统\"><a class=\"markdownIt-Anchor\" href=\"#alpine操作系统\">#</a> Alpine 操作系统</h2>\n<p>Alpine 操作系统主要是面向安全的轻量级 Linux 发行版，它和其它的发行版不同之处在于，Alpine 采用了 musllibc 和 busybox 以减少系统体积和运行时资源消耗，但功能上比 busybox 又完善的多 ，因此越来越得到开源社区的青睐。在保持瘦身的同时，Alpine 还提供了自己的包管理工具【CentOS 是 yum，ubuntu 是 apt-get】，可以通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wa2dzLmFscGluZWxpbnV4Lm9yZy9wYWNrYWdlcw==\">Alpine 包查询网站</span> ，来进行查看，例如下图所示，搜索自己需要安装的包进行查看</p>\n<p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20201206093447554.png\" alt=\"image-20201206093447554\"></p>\n<p>然后通过 apk add vim 来进行安装即可。</p>\n<p>Alpine Docker 镜像也继承了 Alpine Linux 发行版的优势，相比于其它的 Docker 镜像，它的容量体积非常小，仅仅只有 5MB，我们通过打开 DockerHub 中 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5odWIuZG9ja2VyLmNvbS9fL2FscGluZQ==\">Alpine 的官网</span></p>\n<p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20201206093922397.png\" alt=\"image-20201206093922397\"></p>\n<p>可以发现，它提供了只有 5MB 的系统镜像可供我们进行下载使用</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 下载 alpine 镜像</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> pull alpine</pre></td></tr></table></figure><p>同时，它还列举了一个例子 【通过制作一个 mysql 镜像】</p>\n<p><img data-src=\"images/image-20201206094302242.png\" alt=\"image-20201206094302242\"></p>\n<p>使用 Alpine 和 Ubuntu 制作出来的镜像一个是 36.8MB 一个是 145MB，相差 4 倍多</p>\n<p>目前 Docker 官方已经开始推荐 Alpine 替代之前的 Ubuntu 作为基础镜像环境，这样所带来的好处包括：镜像下载速度更快、镜像安全性提高、主机之间的切换更方便、占用内存更少等特点。</p>\n<h2 id=\"使用alpine镜像\"><a class=\"markdownIt-Anchor\" href=\"#使用alpine镜像\">#</a> 使用 Alpine 镜像</h2>\n<p>我们通过下面命令，能够非常快的运行一个 Alpine 容器【本地不存在会去官方下载】，并输出 hello alpine</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run alpine <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hello alpine\"</span></pre></td></tr></table></figure><p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20201206094817959.png\" alt=\"image-20201206094817959\"></p>\n<h2 id=\"迁移至alpine\"><a class=\"markdownIt-Anchor\" href=\"#迁移至alpine\">#</a> 迁移至 Alpine</h2>\n<p>目前，大部分 Docker 官方镜像，都已经提供了 Alpine 版本镜像的支持，我们非常容易镜像迁移</p>\n<p>例如，通过 Nginx 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5odWIuZG9ja2VyLmNvbS9fL25naW54\">官方 DockerHub 地址</span>，我们可以看到，也专门有 alpine 稳定版本</p>\n<p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20201206095346672.png\" alt=\"image-20201206095346672\"></p>\n<p>还有其它一些官方镜像也都提供了 alpine 版本，我们可以在</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ubuntu/debian -<span class=\"token operator\">></span> alpine</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>python:2.7 -<span class=\"token operator\">></span> python:2.7-alpine</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>ruby:2.3 -<span class=\"token operator\">></span> ruby:2.3-alpine</pre></td></tr></table></figure><p>另外，如果我们想要在 alpine 的基础上进行一些软件的安装，可以使用下面的命令</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>apk <span class=\"token function\">add</span> --no-cache <span class=\"token operator\">&lt;</span>package<span class=\"token operator\">></span></pre></td></tr></table></figure><h2 id=\"思考\"><a class=\"markdownIt-Anchor\" href=\"#思考\">#</a> 思考</h2>\n<p>本段来源于 V2EX 上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudjJleC5jb20vdC81ODE4ODg=\">提问</span></p>\n<p>上面其实我们已经提到了很多关于 alpine 的优势，比如体积小，并且很多官方的 Docker 镜像都提供了基于 alpine 的版本。那如果 alpine 版本没有任何坑的话，从体积小，并且能满足使用正常使用的话，这相比于 CentOS、Ubuntu 和 Debian 的镜像，就拥有非常大的优势了，那么以后这些发行版的进行也就没有存在的必要，真实是这样的么？</p>\n<p>下面是针对上述问题，最后的总结</p>\n<ul>\n<li>首先在基于 alpine 的操作系统上编写 Dockerfile 制作新镜像，并不会像其他操作系统一样方便，甚至会出现 alpine 中不存在的情况。</li>\n<li>虽然每个单个的基于 alpine 的软件镜像是明显少于其他操作系统，但是如果多个镜像【包括每个镜像运行的多个容器】，使用 了同一个基础镜像，是不会花费额外的空间【归结于 docker 的 Overlay 文件系统】</li>\n<li>有些软件没办法在 Alpine 中运行，因为 alpine 不像其它发行版那样使用 CGLIBC【MySQL 没有 Alpine 镜像】</li>\n</ul>\n<h2 id=\"参考\"><a class=\"markdownIt-Anchor\" href=\"#参考\">#</a> 参考</h2>\n<ul>\n<li><code>Alpine</code>  官网：<span class=\"exturl\" data-url=\"aHR0cDovL2FscGluZWxpbnV4Lm9yZy8=\">http://alpinelinux.org/</span></li>\n<li><code>Alpine</code>  官方仓库：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FscGluZWxpbnV4\">https://github.com/alpinelinux</span></li>\n<li><code>Alpine</code>  官方镜像：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fL2FscGluZS8=\">https://hub.docker.com/_/alpine/</span></li>\n<li><code>Alpine</code>  官方镜像仓库：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dsaWRlcmxhYnMvZG9ja2VyLWFscGluZQ==\">https://github.com/gliderlabs/docker-alpine</span></li>\n</ul>\n",
            "tags": [
                "Docker"
            ]
        },
        {
            "id": "https://hahayixiao2.github.io/computer-science/container/DockerDesktop%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/dockerdesktop/",
            "url": "https://hahayixiao2.github.io/computer-science/container/DockerDesktop%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/dockerdesktop/",
            "title": "dockerDesktop笔记",
            "date_published": "2022-05-04T05:15:48.000Z",
            "content_html": "<h1 id=\"dockerdesktop入门简介\"><a class=\"markdownIt-Anchor\" href=\"#dockerdesktop入门简介\">#</a> DockerDesktop 入门简介</h1>\n<h2 id=\"参考\"><a class=\"markdownIt-Anchor\" href=\"#参考\">#</a> 参考</h2>\n<p>参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAyMjA1OTg5NQ==\">https://segmentfault.com/a/1190000022059895</span></p>\n<h2 id=\"介绍\"><a class=\"markdownIt-Anchor\" href=\"#介绍\">#</a> 介绍</h2>\n<p>Docker Desktop 是一款专门为 Windows 和 Mac 提供桌面化的容器开发环境，在 Windows 中，Docker Desktop 使用了 Windows 的 Hyper-V 虚拟化技术，因此需要一台打开了硬件虚拟化的电脑，并且安装的是 Windows10 专业版以上的系统。</p>\n<h2 id=\"下载\"><a class=\"markdownIt-Anchor\" href=\"#下载\">#</a> 下载</h2>\n<p>首先到官网下载对应版本的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS9wcm9kdWN0cy9kb2NrZXItZGVza3RvcA==\">Docker Desktop 安装包</span></p>\n<h2 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\">#</a> 安装</h2>\n<p>首先我们需要：启用或关闭 Windows 功能</p>\n<p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20201209171318151.png\" alt=\"image-20201209171318151\"></p>\n<p>然后勾选下面的选项</p>\n<p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20201209171418171.png\" alt=\"image-20201209171418171\"></p>\n<p>然后开始运行我们下载好的 DockerDesktop.exe，我们进行安装过程中，首先会进行一系列的检查，包括是否开启虚拟化，以及是否满足条件</p>\n<h2 id=\"运行\"><a class=\"markdownIt-Anchor\" href=\"#运行\">#</a> 运行</h2>\n<p>安装完成后，点击图片 Docker Desktop</p>\n<p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20201209170935134.png\" alt=\"image-20201209170935134\"></p>\n<p>这个问题是因为我们使用的 wsl2 版本太旧，需要我们手动更新一下，首先根据提示去微软官网下载最新版的 wsl2 安装包，然后进行安装：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93c2xzdG9yZXN0b3JhZ2UuYmxvYi5jb3JlLndpbmRvd3MubmV0L3dzbGJsb2Ivd3NsX3VwZGF0ZV94NjQubXNp\">安装包点我传送</span></p>\n<p>然后在重新安装，即可完成我们 Docker Desktop</p>\n<p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20201209171230973.png\" alt=\"image-20201209171230973\"></p>\n<p>然后我们打开 powershell 即可查看到我们安装的 docker 版本了</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> --version</pre></td></tr></table></figure><p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20201209172301044.png\" alt=\"image-20201209172301044\"></p>\n<p>下面就可以安装在 Linux 使用 Docker 的操作，到 Windows 进行操作了～</p>\n",
            "tags": [
                "Docker"
            ]
        },
        {
            "id": "https://hahayixiao2.github.io/computer-science/container/Docker/docker/",
            "url": "https://hahayixiao2.github.io/computer-science/container/Docker/docker/",
            "title": "docker笔记",
            "date_published": "2022-05-02T12:56:48.000Z",
            "content_html": "<h2 id=\"docker\"><a class=\"markdownIt-Anchor\" href=\"#docker\">#</a> docker</h2>\n<h3 id=\"10-docker-安装步骤\"><a class=\"markdownIt-Anchor\" href=\"#10-docker-安装步骤\">#</a> 1.0 docker 安装步骤</h3>\n<p><img data-src=\"/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B.png\" alt=\"安装流程\"></p>\n<p>运行 docker run hello-world 能出现这个说明 docker 已经安装成功了！</p>\n<h4 id=\"101-docker-配置阿里云加速\"><a class=\"markdownIt-Anchor\" href=\"#101-docker-配置阿里云加速\">#</a> 1.0.1 docker 配置阿里云加速</h4>\n<p>登录阿里云 -&gt; 选择容器镜像服务 -&gt; 选择镜像加速器</p>\n<p>共有 ubuntu，centos，mac，windows 版本</p>\n<p>centos 配置</p>\n<pre><code class=\"language-linux\">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'\n&#123;\n  &quot;registry-mirrors&quot;: [&quot;https://scg3prw2.mirror.aliyuncs.com&quot;]\n&#125;\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docke2.r\n</code></pre>\n<h3 id=\"20-docker常用命令\"><a class=\"markdownIt-Anchor\" href=\"#20-docker常用命令\">#</a> 2.0 docker 常用命令</h3>\n<h4 id=\"201-帮助启动类命令\"><a class=\"markdownIt-Anchor\" href=\"#201-帮助启动类命令\">#</a> 2.0.1 帮助启动类命令</h4>\n<pre><code>1. 启动docker ：systemctl start docker\n2. 停止docker ：systemctl stop docker\n3. 重启docker：systemctl restart docker\n4. 查看docker状态：systemctl status docker\n5. 开机启动：systemctl enable docker\n6. 查看docker概要信息：docker --info\n7. 查看docker总体帮助文档：docker --help\n8. 查看docker命令帮助文档：docker具体命令 --help\n</code></pre>\n<h4 id=\"202-镜像命令\"><a class=\"markdownIt-Anchor\" href=\"#202-镜像命令\">#</a> 2.0.2 镜像命令</h4>\n<h5 id=\"2021-显示已有镜像\"><a class=\"markdownIt-Anchor\" href=\"#2021-显示已有镜像\">#</a> 2.0.2.1 显示已有镜像</h5>\n<p>列出本地主机上面的镜像</p>\n<p>![](/docker images.jpg)</p>\n<p>如图所示：</p>\n<p>REPOSITORY：表示镜像的仓库源</p>\n<p>TAG: 表示镜像的标签（版本号）</p>\n<p>IMAGE ID: 镜像 ID</p>\n<p>CREATED: 镜像创建的时间</p>\n<p>SIZE: 镜像的大小</p>\n<p>同一个仓库源可以有多个 tag（版本号），使用 REPOSITORY:TAG 来定义不同的镜像，如果不指定则默认使用最新版本如 mysql:latest 镜像</p>\n<p>-options 操作说明：</p>\n<ol>\n<li>-a：列出本地的所有镜像 (含历史)</li>\n<li>-q：只显示镜像 ID</li>\n</ol>\n<h5 id=\"2022-从仓库查找镜像\"><a class=\"markdownIt-Anchor\" href=\"#2022-从仓库查找镜像\">#</a> 2.0.2.2 从仓库查找镜像</h5>\n<p>![](/docker search.jpg)</p>\n<p>NAME：镜像名称</p>\n<p>DESCRIPTION: 镜像说明</p>\n<p>STARTS: 点赞数量</p>\n<p>OFFICIAL: 是否为官方的</p>\n<p>AUTOMATED: 是否是自动构建的</p>\n<p>-option 操作说明：</p>\n<p>–limit ：只列出 N 个镜像，默认 25 个 （docker search --limit 5 redis）</p>\n<h5 id=\"2023-下载镜像\"><a class=\"markdownIt-Anchor\" href=\"#2023-下载镜像\">#</a> 2.0.2.3 下载镜像</h5>\n<p>![](/docker pull.png)</p>\n<p>下载镜像</p>\n<p>1.docker pull 镜像名字 [:TAG]</p>\n<p>2.docker pull 镜像名字</p>\n<p>(1). 没有 TAG 就是最新版 = docker pull 镜像名字:latest</p>\n<h5 id=\"2024-查看docker资源占用情况\"><a class=\"markdownIt-Anchor\" href=\"#2024-查看docker资源占用情况\">#</a> 2.0.2.4 查看 docker 资源占用情况</h5>\n<p>docker system df</p>\n<p>![](/docker system df.png)</p>\n<h5 id=\"2025-删除镜像\"><a class=\"markdownIt-Anchor\" href=\"#2025-删除镜像\">#</a> 2.0.2.5  删除镜像</h5>\n<p>![](/docker rmi.png)</p>\n<p>1.docker rmi -f 镜像 id（删除单个)</p>\n<p>2.docker rmi -f 镜像名 1:tag 镜像名 2:tag (删除多个)</p>\n<p>3.docker rmi -f $(docker images -qa) （删除全部）</p>\n<h5 id=\"2026-启动交互式容器\"><a class=\"markdownIt-Anchor\" href=\"#2026-启动交互式容器\">#</a> 2.0.2.6 启动交互式容器</h5>\n<p>docker run（前台命令行）</p>\n<p>–name =“容器的新名字”</p>\n<p>-d：后台运行容器并且返回容器 id，也即启动守护式容器（后台运行）；</p>\n<p>-i：以交互模式运行容器，通常与 - t 同时使用，</p>\n<p>-t：为容器分配一个伪输入终端，通常与 - i 一起使用，也即启动交互式容器（前台有伪终端，等待交互）</p>\n<p>-P：随机端口映射，大写 P</p>\n<p>-p：指定端口映射，小写 p</p>\n<p>![image-20220201150011636](/docker run.png)</p>\n<h5 id=\"2027-查看容器\"><a class=\"markdownIt-Anchor\" href=\"#2027-查看容器\">#</a> 2.0.2.7 查看容器</h5>\n<p>docker ps</p>\n<p>-a: 列出所有正在运行的容器</p>\n<p>-l：显示最近创建的容器</p>\n<p>-n: 显示最近 n 个创建的容器</p>\n<p>-q：静默模式，只显示容器编号</p>\n<h5 id=\"2028-退出容器\"><a class=\"markdownIt-Anchor\" href=\"#2028-退出容器\">#</a> 2.0.2.8 退出容器</h5>\n<p>（1）.exit： run 进去容器，exit 退出，容器停止</p>\n<p>（2）.ctrl+p+q run 进去容器，ctrl+p+q 退出，容器不停止<img data-src=\"\" alt=\"\"></p>\n<h5 id=\"2029-启动容器\"><a class=\"markdownIt-Anchor\" href=\"#2029-启动容器\">#</a> 2.0.2.9 启动容器</h5>\n<p>（1）.docker start 容器 ID 或者容器名</p>\n<h5 id=\"20210-停止容器\"><a class=\"markdownIt-Anchor\" href=\"#20210-停止容器\">#</a> 2.0.2.10 停止容器</h5>\n<p>（1）.docker stop 容器 ID 或者容器名</p>\n<h5 id=\"20211-重启容器\"><a class=\"markdownIt-Anchor\" href=\"#20211-重启容器\">#</a> 2.0.2.11 重启容器</h5>\n<p>（1）.docker restart 容器 ID 或者容器名</p>\n<h5 id=\"20212-强制停止容器\"><a class=\"markdownIt-Anchor\" href=\"#20212-强制停止容器\">#</a> 2.0.2.12 强制停止容器</h5>\n<p>（1）.docker kill 容器 ID 或者容器名</p>\n<h5 id=\"20213-删除已停止的容器\"><a class=\"markdownIt-Anchor\" href=\"#20213-删除已停止的容器\">#</a> 2.0.2.13 删除已停止的容器</h5>\n<p>（1）.docker rm 容器 ID</p>\n<p>（2）.dockers 删除多个容器</p>\n<p>​        1.docker rm -f (docker ps -a -q)</p>\n<p>​        2.docker ps -a -q |xagrs docker rm</p>\n<h5 id=\"20214-查看日志\"><a class=\"markdownIt-Anchor\" href=\"#20214-查看日志\">#</a> 2.0.2.14 查看日志</h5>\n<p>docker logs 容器 ID</p>\n<h5 id=\"20215-查看容器内运行的进程\"><a class=\"markdownIt-Anchor\" href=\"#20215-查看容器内运行的进程\">#</a> 2.0.2.15 查看容器内运行的进程</h5>\n<p>docker top 容器 ID</p>\n<h5 id=\"20216-重新进入终端\"><a class=\"markdownIt-Anchor\" href=\"#20216-重新进入终端\">#</a> 2.0.2.16 重新进入终端</h5>\n<p>（1）.docker exec -it 容器 ID /bin/bash  (bash)（推荐使用）</p>\n<p>exec 是在容器中打开新的终端，并且可以启动新的进程，用 exit 退出不会导致容器的停止。</p>\n<p>（2）.docker attach 容器 ID</p>\n<p>attach 直接进入容器启动命令的终端，不会启动新的进程，用 exit 退出会导致容器的停止。</p>\n<h5 id=\"20217-拷贝文件\"><a class=\"markdownIt-Anchor\" href=\"#20217-拷贝文件\">#</a> 2.0.2.17 拷贝文件</h5>\n<p>docker cp 容器 ID: 容器内的路径 目标主机的地址</p>\n<h5 id=\"20218-导入和导出容器\"><a class=\"markdownIt-Anchor\" href=\"#20218-导入和导出容器\">#</a> 2.0.2.18 导入和导出容器</h5>\n<p>导出：docker export 容器 ID &gt; 文件名.tar</p>\n<p>导入：cat 文件名.tar | docker import - 镜像用户 / 镜像名：镜像版本号</p>\n<h3 id=\"30-docker-镜像\"><a class=\"markdownIt-Anchor\" href=\"#30-docker-镜像\">#</a> 3.0 docker 镜像</h3>\n<p>1. 是一种轻量级，可执行的独立软件包，它包含运行某个软件所需要的所有内容，我们把应用程序和配置依赖打包好形成一个可以交付的运行环境 (包括代码，运行时需要的库，环境变量和配置文件等)，这个打包好的运行环境就是 image 的镜像文件</p>\n<p>只有通过这个镜像文件才能生成 Docker 容器实例（类似 Java 中 new 出来的一个对象)</p>\n<p>2. 联合文件系统 UnionFS:Union 文件系统（UnionFS）是一种分层，轻量级并且高新能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>\n<p>3.docker 镜像分层最大的一个好处就是为了资源共享，方便复制迁移，就是为了复用。</p>\n<p>docker commit 提交容器副本使之成为一个新的镜像</p>\n<p>docker commit -m=“提交的描述信息” -a=“作者” 容器 ID 要创建的目标镜像名：[标签名]</p>\n<h3 id=\"40-docker-容器数据卷\"><a class=\"markdownIt-Anchor\" href=\"#40-docker-容器数据卷\">#</a> 4.0 docker 容器数据卷</h3>\n<p>（1）. 是什么？</p>\n<p>1.Docker 挂载主机目录访问如果出现 cannnot open directory .: Permission denied</p>\n<p>解决办法：在挂载目录后多加一个–privileged=true 参数即可</p>\n<p>2. 卷就是目录或者文件，存在于一个或者多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System 提供一些用于持续储存或者共享数据的特性。</p>\n<p>卷的设计目的就是数据持久化，完全的独立于容器的生存周期，因此 Docker 不会在容器删除的时候删除其挂载的数据卷</p>\n<p>（2）. 能干什么？</p>\n<p>1. 将运用与运行的环境打包成镜像，run 后形成容器实例运行，但是我们对数据的要求希望是持久化的</p>\n<p>Docker 容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p>\n<p>为了能保存数据在 docker 中我们使用卷。</p>\n<p>特点：</p>\n<p>1. 数据卷在容器之间共享或重用数据</p>\n<p>2. 卷中的更改可以直接实时生效</p>\n<p>3. 数据卷中的更改不会包含在镜像的更新中</p>\n<p>4. 数据卷的生命周期一直持续到没有容器使用它为止</p>\n<p>（3）. 案例</p>\n<p>1.docker run -it --privileged=true -v / 宿主机绝对路径目录:/ 容器内目录  镜像名     (如果没有目录 docker 自建)</p>\n<p>2. 查看数据卷是否挂载成功 docker inspect 容器 ID</p>\n<p>3. 容器内的目录可读可写 docker run -it --privileged=true -v / 宿主机绝对路径目录:/ 容器内目录:rw  镜像名</p>\n<p>4. 容器内只能读不能写 docker run -it --privileged=true -v / 宿主机绝对路径目录:/ 容器内目录:ro 镜像名</p>\n<p>（4）. 卷的继承和共享</p>\n<p>1.docker run  -it --privileged=true --volumes-from 父类 --name u2 ubuntu</p>\n<h3 id=\"50-docker-常规软件的安装\"><a class=\"markdownIt-Anchor\" href=\"#50-docker-常规软件的安装\">#</a> 5.0 docker 常规软件的安装</h3>\n<h4 id=\"501步骤\"><a class=\"markdownIt-Anchor\" href=\"#501步骤\">#</a> 5.0.1. 步骤</h4>\n<p>（1）. 搜索镜像</p>\n<p>（2）. 拉取镜像</p>\n<p>（3）. 查看镜像</p>\n<p>（4）. 启动镜像</p>\n<p>（5）. 停止容器</p>\n<p>（6）. 移除容器</p>\n<h4 id=\"502安装tomcat\"><a class=\"markdownIt-Anchor\" href=\"#502安装tomcat\">#</a> 5.0.2. 安装 tomcat</h4>\n<p>（1）.docker search tomcat</p>\n<p>（2）.docker pull tomcat</p>\n<p>（3）.docker images</p>\n<p>（4）.docker run -itd -p 8080:8080 --name=t1  tomcat</p>\n<p>（5）. 访问报 404 (1. 没有关闭防火墙，2. 进入 tomcat docker exec -it 容器 ID/bin/bash ，然后 rm -r webapps , 最后 mv webapps.dist webapps）</p>\n<p>（6）.docker stop 容器 ID</p>\n<p>（7）.docker rmi 镜像 ID</p>\n<h4 id=\"503安装mysql\"><a class=\"markdownIt-Anchor\" href=\"#503安装mysql\">#</a> 5.0.3. 安装 mysql</h4>\n<p>（1）.docker search mysql</p>\n<p>（2）.docker pull mysql:5…7</p>\n<p>（3）.docker images</p>\n<p>（4）. docker run -itd -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 --name=mysql1  mysql:5.7</p>\n<p>（5）. docker exec -it 容器 ID /bin/bash</p>\n<p>（6）.docker stop 容器 ID</p>\n<p>（7）.docker rmi 镜像 ID</p>\n<p>配置 utf8</p>\n<p>（8）.docker run -d -p 3306:3306 --privileged=true -v  /cgcuse/mysql/log:/var/log/mysql -v /cgcuse/mysql/data:/var/lib/mysql -v     /cgcuse/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  --name=mysql mysql:5.7</p>\n<p>（9）.cd/cgcuse/mysql/conf  然后 vim my.conf</p>\n<p>最后 ：</p>\n<p>[client]<br>\ndefault_character_set=utf8<br>\n[mysqld]<br>\ncollation_server=utf8_general_ci<br>\ncharacter_set_server=utf8</p>\n<h4 id=\"504安装redis\"><a class=\"markdownIt-Anchor\" href=\"#504安装redis\">#</a> 5.0.4 安装 redis</h4>\n<p>（1）.docker search redis</p>\n<p>（2）.docker pull mysql:5…7</p>\n<p>（3）.docker images</p>\n<p>（4）.docker run -itd -p 6379:6379 --name=redistest redis:6.0.8</p>\n<p>（5）.docker exec -it 容器 ID /bin/bash</p>\n<p>（6）.redis-cli</p>\n<p>（7）.docker stop 容器 ID</p>\n<p>（8）.docker rmi 镜像 ID</p>\n<h3 id=\"60-mysql主从复制\"><a class=\"markdownIt-Anchor\" href=\"#60-mysql主从复制\">#</a> 6.0 mysql 主从复制</h3>\n<h4 id=\"601新建主服务器容器实例3307\"><a class=\"markdownIt-Anchor\" href=\"#601新建主服务器容器实例3307\">#</a> 6.0.1. 新建主服务器容器实例 3307</h4>\n<pre><code>docker run -d -p 3307:3306 --privileged=true -v  /cgcuse/mysql-master/log:/var/log/mysql -v /cgcuse/mysql-master/data:/var/lib/mysql -v  /cgcuse/mysql-master/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root  --name=mysql-master mysql:5.7\n</code></pre>\n<h4 id=\"602进入-cgcusemysql-masterconf-目录下新建mycnf-vim-mycnf\"><a class=\"markdownIt-Anchor\" href=\"#602进入-cgcusemysql-masterconf-目录下新建mycnf-vim-mycnf\">#</a> 6.0.2. 进入 /cgcuse/mysql-master/conf 目录下新建 my.cnf       vim my.cnf</h4>\n<pre><code>[mysqld]\n## 设置server_id，同一局域网中需要唯一\nserver_id=101 \n## 指定不需要同步的数据库名称\nbinlog-ignore-db=mysql  \n## 开启二进制日志功能\nlog-bin=mall-mysql-bin  \n## 设置二进制日志使用内存大小（事务）\nbinlog_cache_size=1M  \n## 设置使用的二进制日志格式（mixed,statement,row）\nbinlog_format=mixed  \n## 二进制日志过期清理时间。默认值为0，表示不自动清理。\nexpire_logs_days=7  \n## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。\n## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致\nslave_skip_errors=1062\n</code></pre>\n<h4 id=\"603修改完配置后重启master实例\"><a class=\"markdownIt-Anchor\" href=\"#603修改完配置后重启master实例\">#</a> 6.0.3. 修改完配置后重启 master 实例</h4>\n<p>docker restart mysql-master</p>\n<h4 id=\"604进入容器\"><a class=\"markdownIt-Anchor\" href=\"#604进入容器\">#</a> 6.0.4. 进入容器</h4>\n<p>docker exec -it 容器 ID /bin/bash</p>\n<p>mysql -uroot -proot</p>\n<h4 id=\"605master容器实例内创建数据同步用户\"><a class=\"markdownIt-Anchor\" href=\"#605master容器实例内创建数据同步用户\">#</a> 6.0.5.master 容器实例内创建数据同步用户</h4>\n<p>create user ‘slave’@’%’ identified by ‘123456’;</p>\n<p>grant replication slave ,replication client on <em>.</em> to ‘slave’@’%’；</p>\n<h4 id=\"606新建从服务器容器实例3308\"><a class=\"markdownIt-Anchor\" href=\"#606新建从服务器容器实例3308\">#</a> 6.0.6. 新建从服务器容器实例 3308</h4>\n<pre><code>docker run -d -p 3308:3306 --privileged=true -v  /cgcuse/mysql-slave/log:/var/log/mysql -v /cgcuse/mysql-slave/data:/var/lib/mysql -v  /cgcuse/mysql-slave/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root  --name=mysql-slave mysql:5.7\n</code></pre>\n<h4 id=\"607进入-cgcusemysql-slaveconf-目录下新建mycnf-vim-mycnf\"><a class=\"markdownIt-Anchor\" href=\"#607进入-cgcusemysql-slaveconf-目录下新建mycnf-vim-mycnf\">#</a> 6.0.7. 进入 /cgcuse/mysql-slave/conf 目录下新建 my.cnf       vim my.cnf</h4>\n<pre><code>[mysqld]\n## 设置server_id，同一局域网中需要唯一\nserver_id=102\n## 指定不需要同步的数据库名称\nbinlog-ignore-db=mysql  \n## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用\nlog-bin=mall-mysql-slave1-bin  \n## 设置二进制日志使用内存大小（事务）\nbinlog_cache_size=1M  \n## 设置使用的二进制日志格式（mixed,statement,row）\nbinlog_format=mixed  \n## 二进制日志过期清理时间。默认值为0，表示不自动清理。\nexpire_logs_days=7  \n## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。\n## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致\nslave_skip_errors=1062  \n## relay_log配置中继日志\nrelay_log=mall-mysql-relay-bin  \n## log_slave_updates表示slave将复制事件写进自己的二进制日志\nlog_slave_updates=1  \n## slave设置为只读（具有super权限的用户除外）\nread_only=1\n</code></pre>\n<h4 id=\"608修改完配置后重启slave实例\"><a class=\"markdownIt-Anchor\" href=\"#608修改完配置后重启slave实例\">#</a> 6.0.8. 修改完配置后重启 slave 实例</h4>\n<p>docker restart mysql-slave</p>\n<h4 id=\"609在主数据库中查看主从同步状态\"><a class=\"markdownIt-Anchor\" href=\"#609在主数据库中查看主从同步状态\">#</a> 6.0.9. 在主数据库中查看主从同步状态</h4>\n<p>show master status;</p>\n<h4 id=\"6010进入mysql-slave容器\"><a class=\"markdownIt-Anchor\" href=\"#6010进入mysql-slave容器\">#</a> 6.0.10. 进入 mysql-slave 容器</h4>\n<p>docker exec -it 容器 ID  /bin/bash</p>\n<h4 id=\"6011在数据库中配置主从复制\"><a class=\"markdownIt-Anchor\" href=\"#6011在数据库中配置主从复制\">#</a> 6.0.11. 在数据库中配置主从复制</h4>\n<p>change master to master_host=‘宿主机 ip’, master_user=‘slave’, master_password=‘123456’, master_port=3307, master_log_file=‘mall-mysql-bin.000001’, master_log_pos=617, master_connect_retry=30;</p>\n<p>master_host：主数据库的 IP 地址；</p>\n<p>master_port：主数据库的运行端口；</p>\n<p>master_user：在主数据库创建的用于同步数据的用户账号；</p>\n<p>master_password：在主数据库创建的用于同步数据的用户密码；</p>\n<p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取 File 参数；</p>\n<p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取 Position 参数；</p>\n<p>master_connect_retry：连接失败重试的时间间隔，单位为秒。</p>\n<h4 id=\"6012在从数据库中查看主从同步状态\"><a class=\"markdownIt-Anchor\" href=\"#6012在从数据库中查看主从同步状态\">#</a> 6.0.12. 在从数据库中查看主从同步状态</h4>\n<p>show slave status \\G;</p>\n<h4 id=\"6013在从数据库中开启主从同步\"><a class=\"markdownIt-Anchor\" href=\"#6013在从数据库中开启主从同步\">#</a> 6.0.13. 在从数据库中开启主从同步</h4>\n<p>start slave;</p>\n<h4 id=\"6014查看从数据库状态发现已经同步\"><a class=\"markdownIt-Anchor\" href=\"#6014查看从数据库状态发现已经同步\">#</a> 6.0.14. 查看从数据库状态发现已经同步</h4>\n<p>show slave status \\G;</p>\n<h4 id=\"6015主从复制测试\"><a class=\"markdownIt-Anchor\" href=\"#6015主从复制测试\">#</a> 6.0.15. 主从复制测试</h4>\n<p>navicate 连接主库添加，从库查看或者命令添加；</p>\n<h3 id=\"70分布式存储\"><a class=\"markdownIt-Anchor\" href=\"#70分布式存储\">#</a> 7.0. 分布式存储</h3>\n<h4 id=\"701哈希取余算法\"><a class=\"markdownIt-Anchor\" href=\"#701哈希取余算法\">#</a> 7.0.1. 哈希取余算法</h4>\n<p>2 亿条记录就是 2 亿个 k，v，我们单机不行必须要分布式多机，假设有 3 台机器构成一个集群，用户每次读写操作都是根据公式；</p>\n<p>hash (key)% N 个机器台数，计算出哈希值，用来决定数据映射到哪一个结点上；</p>\n<p>优点：简单粗暴，直接有效，只需要预估好数据规划好节点，列如 3 台，8 台，10 台，就能保证一段时间的数据支撑，使用 Hash 算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并且维护这些请求信息）, 起到负载均衡 + 分而治之的作用；</p>\n<p>缺点：原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash (key)/3 会变成 Hash (key) /?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。</p>\n<p>某个 redis 机器宕机了，由于台数数量变化，会导致 hash 取余全部数据重新洗牌。</p>\n<h4 id=\"702一致性哈希算法\"><a class=\"markdownIt-Anchor\" href=\"#702一致性哈希算法\">#</a> 7.0.2. 一致性哈希算法</h4>\n<p>1. 目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不 OK 了。</p>\n<p>步骤:</p>\n<p>(1). 算法构建一致性哈希环：</p>\n<p>​     一致性哈希算法必然有个 hash 函数并按照算法产生 hash 值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个 hash 空间 [0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连 (0 = 2^32), 这样让它逻辑上形成了一个环形空间。</p>\n<p>​       它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性 Hash 算法是对 2<sup>32 取模，简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数 H 的值空间为 0-2</sup>32-1（即哈希值是一个 32 位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、…… 直到 2<sup>32-1，也就是说 0 点左侧的第一个点代表 2</sup>32-1， 0 和 2<sup>32-1 在零点中方向重合，我们把这个由 2</sup>32 个点组成的圆环称为 Hash 环。</p>\n<p>(2). 服务器 IP 节点映射</p>\n<p>​       将集群中各个 IP 节点映射到环上的某一个位置。  将各个服务器使用 Hash 进行一个哈希，具体可以选择服务器的 IP 或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如 4 个节点 NodeA、B、C、D，经过 IP 地址的哈希函数计算 (hash (ip))，使用 IP 地址哈希后在环空间的位置如下：</p>\n<p>(3).key 落到服务器的落建规则</p>\n<p>​       当我们需要存储一个 kv 键值对时，首先计算 key 的 hash 值，hash (key)，将这个 key 使用相同的函数 Hash 计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针 “行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>\n<p>​       如我们有 Object A、Object B、Object C、Object D 四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性 Hash 算法，数据 A 会被定为到 Node A 上，B 被定为到 Node B 上，C 被定为到 Node C 上，D 被定为到 Node D 上。</p>\n<p>优点：</p>\n<p><strong>容错性</strong></p>\n<p>假设 Node C 宕机，可以看到此时对象 A、B、D 不会受到影响，只有 C 对象被重定位到 Node D。一般的，在一致性 Hash 算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是 C 挂了，受到影响的只是 B、C 之间的数据，并且这些数据会转移到 D 进行存储。</p>\n<p><strong>扩展性</strong></p>\n<p>数据量增加了，需要增加一台节点 NodeX，X 的位置在 A 和 B 之间，那收到影响的也就是 A 到 X 之间的数据，重新把 A 到 X 的数据录入到 X 上即可，</p>\n<p>不会导致 hash 取余全部数据重新洗牌。</p>\n<p>缺点：</p>\n<p>Hash 环的数据倾斜问题</p>\n<p>一致性 Hash 算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，</p>\n<p>为了在节点数目发生改变时尽可能少的迁移数据</p>\n<p>将所有的存储节点排列在收尾相接的 Hash 环上，每个 key 在计算 Hash 后会顺时针找到临近的存储节点存放。</p>\n<p>而当有节点加入或退出时仅影响该节点在 Hash 环上顺时针相邻的后续节点。</p>\n<p>优点</p>\n<p>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p>\n<p>缺点</p>\n<p>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p>\n<h4 id=\"703哈希槽算法\"><a class=\"markdownIt-Anchor\" href=\"#703哈希槽算法\">#</a> 7.0.3. 哈希槽算法</h4>\n<p>1. 是什么？</p>\n<p>哈希槽实质就是一个数组，数组 [0,2^14 -1] 形成 hash slot 空间。</p>\n<p>2. 可以干什么？</p>\n<p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</p>\n<p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p>\n<p>哈希解决的是映射问题，使用 key 的哈希值来计算所在的槽，便于数据分配。</p>\n<p>3. 多少个 hash 槽？</p>\n<p>一个集群只能有 16384 个槽，编号 0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对 key 求哈希值，然后对 16384 取余，余数是几 key 就落入对应的槽里。slot = CRC16 (key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>\n<p>4. 计算</p>\n<p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key 之 A 、B 在 Node2， key 之 C 落在 Node3 上</p>\n<h3 id=\"80-redis-3主3从集群\"><a class=\"markdownIt-Anchor\" href=\"#80-redis-3主3从集群\">#</a> 8.0 Redis 3 主 3 从集群</h3>\n<h4 id=\"801-3主3从redis集群配置\"><a class=\"markdownIt-Anchor\" href=\"#801-3主3从redis集群配置\">#</a> 8.0.1 3 主 3 从 redis 集群配置</h4>\n<p>1. 关闭防火墙 + 启动 docker 后台服务、</p>\n<p>（1）. systemctl start docker</p>\n<p>2. 新建 6 个 docker 容器实例</p>\n<pre><code>docker run -d --name redis-node-1 --net host --privileged=true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381\n\ndocker run -d --name redis-node-2 --net host --privileged=true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382\n\ndocker run -d --name redis-node-3 --net host --privileged=true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383\n\ndocker run -d --name redis-node-4 --net host --privileged=true -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384\n\ndocker run -d --name redis-node-5 --net host --privileged=true -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385\n\ndocker run -d --name redis-node-6 --net host --privileged=true -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386\n</code></pre>\n<p><img data-src=\"/redis.jpg\" alt=\"\"></p>\n<p>3. 进入容器 redis-node-1 并为 6 台机器构建集群关系</p>\n<p>（1）. 进入容器 docker exec -it 容器 ID  /bin/bash</p>\n<p>（2）. 构建主从关系</p>\n<pre><code>redis-cli --cluster create 1.15.175.46:6381 1.15.175.46:6382 1.15.175.46:6383 1.15.175.46:6384 1.15.175.46:6385 1.15.175.46:6386 --cluster-replicas 1\n</code></pre>\n<p>出现以下结果就成功了。</p>\n<p><img data-src=\"/redis-hash.jpg\" alt=\"\"></p>\n<p>4. 查看集群状态</p>\n<p>（1）.redis-cli -p 6381</p>\n<p>（2）.cluster info</p>\n<p>（3）.cluster nodes</p>\n<h4 id=\"802-3从容错切换迁移案例\"><a class=\"markdownIt-Anchor\" href=\"#802-3从容错切换迁移案例\">#</a> 8.0.2 3 从容错切换迁移案例</h4>\n<p>1. 数据读写存储</p>\n<p>（1）. 启动 6 机构成的集群并且使用 exec 进入</p>\n<p>（2）. 对 6381 新增两个 key</p>\n<p>（3）. 防止路由失效加参数 - c 并新增两个 key</p>\n<p>redis-cli -p 6381 -c</p>\n<p>（4）. 查看集群信息</p>\n<p>redis-cli --cluster check 1.15.175.46:6381</p>\n<p>2. 容错切换迁移</p>\n<p>（1）. 主 6381 和从机切换，先停止主机 6381</p>\n<p>1.6381 主机停了，对应的真实从机上位</p>\n<p>2.6381 作为 1 号主机分配的从机以实际情况为准，具体是几号机器就是几号</p>\n<p>docker stop redis-node-1</p>\n<p>（2）. 再次查看集群信息</p>\n<p>docker exec -it redis-node-2 bash</p>\n<p>redis-cli -p 6382 -c</p>\n<p>cluster nodes</p>\n<p>（3）. 先还原之前的 3 主 3 从</p>\n<p>docker start redis-node-1</p>\n<p>docker stop redis-node-5</p>\n<p>docker start redis-node-5</p>\n<p>（4）. 查看集群状态</p>\n<p>redis-cli --cluster check 1.15.175.46:6381</p>\n<h4 id=\"803-3从扩容案例\"><a class=\"markdownIt-Anchor\" href=\"#803-3从扩容案例\">#</a> 8.0.3 3 从扩容案例</h4>\n<p>1. 新建 6387，6388 两个节点 + 新建后启动 + 查看是否 8 节点</p>\n<table>\n<thead>\n<tr>\n<th>docker run -d --name redis-node-7 --net host --privileged=true -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker run -d --name redis-node-8 --net host --privileged=true -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</td>\n</tr>\n<tr>\n<td>docker ps</td>\n</tr>\n</tbody>\n</table>\n<p>2. 进入 6387 容器实例内部</p>\n<p>docker exec -it redis-node-7 bash</p>\n<p>3. 将新增的 6387 节点（空槽号）作为节点加入原集群</p>\n<p>redis-cli --cluster add-node 1.15.175.46:6387 1.15.175.46:6381</p>\n<p>4. 检查集群情况第一次</p>\n<p>redis-cli --cluster check 真实 ip 地址：6381</p>\n<p>5. 重新分派槽号</p>\n<p>命令:redis-cli --cluster <strong>reshard</strong> IP 地址：端口号</p>\n<p>redis-cli --cluster reshard  1.15.175.46:6381</p>\n<p>6. 检查集群情况第二次</p>\n<p>redis-cli --cluster check 真实 ip 地址：6381</p>\n<p>7. 为主节点 6387 分配从节点 6388</p>\n<p>命令：redis-cli --cluster add-node ip: 新 slave 端口 ip: 新 master 端口 --cluster-slave --cluster-master-id 新主机节点 ID</p>\n<p>redis-cli --cluster add-node  1.15.175.46:6388  1.15.175.46:6387 --cluster-slave --cluster-master-id e4781f644d4a4e4d4b4d107157b9ba8144631451------- 这个是 6387 的编号，按照自己实际情况</p>\n<p>8. 检查集群情况第三次</p>\n<p>redis-cli --cluster check 真实 ip 地址：6388</p>\n<h4 id=\"804-3从缩容案例\"><a class=\"markdownIt-Anchor\" href=\"#804-3从缩容案例\">#</a> 8.0.4 3 从缩容案例</h4>\n<p>1. 下线 6387，6388 两个节点</p>\n<p>2. 检查集群情况 1 获得 6388 的节点 ID</p>\n<p>redis-cli --cluster check 真实 ip 地址：6388</p>\n<p>3. 将 6388 删除，从集群中将 4 号从节点 6388 删除</p>\n<p>命令：redis-cli --cluster del-node ip: 从机端口 从机 6388 节点 ID</p>\n<p>redis-cli --cluster del-node 1.15.175.46:6388 5d149074b7e57b802287d1797a874ed7a1a284a8</p>\n<p>4. 将 6387 的槽号清空重新分配本例将清出来的槽号都给 6381</p>\n<p>redis-cli --cluster reshard 1.15.175.46:6381</p>\n<p>5. 检查集群情况第二次</p>\n<p>redis-cli --cluster check 真实 ip 地址：6381</p>\n<p>6. 将 6387 删除</p>\n<p>redis-cli --cluster del-node 1.15.175.46:6387 5d149074b7e57b802287d1797a874ed7a1a284a8</p>\n<p>7. 检查集群情况第三次</p>\n<p>redis-cli --cluster check 真实 ip 地址：6381</p>\n<h3 id=\"90-dockerfile\"><a class=\"markdownIt-Anchor\" href=\"#90-dockerfile\">#</a> 9.0 DockerFile</h3>\n<h4 id=\"901dockerfile构建过程解析\"><a class=\"markdownIt-Anchor\" href=\"#901dockerfile构建过程解析\">#</a> 9.0.1dockerfile 构建过程解析</h4>\n<p>1.Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\n<p>2. 构建过程</p>\n<p>（1）. 编写 Dockerfile 文件</p>\n<p>（2）.docker build 命令构建镜像</p>\n<p>（3）.docker run 运行镜像容器</p>\n<p>3.Dockerfile 内容基础知识</p>\n<p>（1）. 每条保留字指令都必须为大写字母且后面要跟随至少一个参数</p>\n<p>（2）. 指令按照从上到下，顺序执行</p>\n<p>（3）.# 表示注释</p>\n<p>（4）. 每条指令都会创建一个新的镜像层并对镜像进行提交</p>\n<p>4.Docker 执行 Dockerfile 的大致流程</p>\n<p>（1）.docker 从基础镜像运行一个容器</p>\n<p>（2）. 执行一条指令并对容器做出修改</p>\n<p>（3）. 执行类似 docker commit 的操作提交一个新的镜像层</p>\n<p>（4）.docker 再基于刚提交的镜像运行一个新的容器</p>\n<p>（5）. 执行 dockerfile 中的下一条指令直到所有指令都执行完成</p>\n<h4 id=\"902-dockerfile常用保留字指令\"><a class=\"markdownIt-Anchor\" href=\"#902-dockerfile常用保留字指令\">#</a> 9.0.2 DockerFile 常用保留字指令</h4>\n<p><strong>FROM</strong> : 基础镜像当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是 from</p>\n<p><strong>MAINTAINER</strong> : 镜像维护者的姓名和邮箱地址</p>\n<p><strong>RUN</strong> ：</p>\n<p>1. 容器构建的时候需要运行的命令</p>\n<p>2. 两种格式：1.shell 格式，exec 格式</p>\n<p>3.RUN 是在 docker build 时运行</p>\n<p><strong>EXPOSE</strong>: 当前容器对外暴露出的端口</p>\n<p><strong>WORKDIR</strong> : 指定在创建容器后，终端默认登录的进来的工作目录，一个落脚点</p>\n<p><strong>USER</strong> : 指定该镜像以什么样的用户去执行，如果都不指定，默认是 root</p>\n<p><strong>ENV</strong> : 用来在构建镜像过程中设置环境变量</p>\n<p>ENV key value</p>\n<p><strong>ADD</strong> : 将宿主机目录下的文件拷贝进镜像且会自动处理 URL 和解压 tar 压缩包</p>\n<p><strong>COPY</strong> : 类似 ADD ，拷贝文件和目录到镜像中。</p>\n<p>将从构建上下文目录中 &lt;源路径&gt; 的文件 / 目录复制到新的一层的镜像内的 &lt; 目标路径 &gt; 位置</p>\n<p>（1）.COPY src  dest</p>\n<p>（2）.COPY[“src”,“dest”]</p>\n<p>（3）.&lt;src 源路径&gt;: 源文件或者源目录</p>\n<p>（4）.&lt;dest 目标路径&gt;: 容器内的指定路径，该路径不用事先创建好，如果路径不存在，会自动创建</p>\n<p><strong>VOLUME</strong>: 容器数据卷，用于数据保存和持久化工作</p>\n<p><strong>CMD</strong>: 指定容器启动后要干的事情（指令跟 RUN 相似）可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p>\n<p>1.RUN 是在 docker build 时运行</p>\n<p>2.CMD 是在 docker run 时运行</p>\n<p><strong>ENTRYPOINT</strong>: 指定一个容器启动时要运行的命令，类似 CMD 但是不会被 docker run 之后的参数替换。</p>\n<h4 id=\"903案例\"><a class=\"markdownIt-Anchor\" href=\"#903案例\">#</a> 9.0.3 案例</h4>\n<p>自定义镜像 mycentosjava8（具备 jdk8，ifconfig，vim）</p>\n<p>下载 jdk 文件到 myfile 下</p>\n<p>vim Dockerfile</p>\n<pre><code>FROM centos\nMAINTAINER haha&lt;haha@136.com&gt;\n \nENV MYPATH /usr/local\nWORKDIR $MYPATH\n \n#安装vim编辑器\nRUN yum -y install vim\n#安装ifconfig命令查看网络IP\nRUN yum -y install net-tools\n#安装java8及lib库\nRUN yum -y install glibc.i686\nRUN mkdir /usr/local/java\n#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置\nADD jdk-8u171-linux-x64.tar.gz /usr/local/java/\n#配置java环境变量\nENV JAVA_HOME /usr/local/java/jdk1.8.0_171\nENV JRE_HOME $JAVA_HOME/jre\nENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH\nENV PATH $JAVA_HOME/bin:$PATH\n \nEXPOSE 80\n \nCMD echo $MYPATH\nCMD echo &quot;success--------------ok&quot;\nCMD /bin/bash\n</code></pre>\n<p>构建</p>\n<p>docker build -t 新镜像名字:tag .</p>\n<p>docker image prune 删除虚悬镜像</p>\n<h4 id=\"904-微服务实战\"><a class=\"markdownIt-Anchor\" href=\"#904-微服务实战\">#</a> 9.0.4 微服务实战</h4>\n<p>1. 新建一个 springboot 微服务项目</p>\n<p>2. 搞定微服务 jar 包</p>\n<p>3.jar 包和 Dockerfile 放在同一个路径下</p>\n<pre><code># 基础镜像使用java\n\nFROM java:8\n\n# 作者\n\nMAINTAINER zzyy\n\n# VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp\n\nVOLUME /tmp\n\n# 将jar包添加到容器中并更名为zzyy_docker.jar\n\nADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar\n\n# 运行jar包\n\nRUN bash -c 'touch /zzyy_docker.jar'\n\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]\n\n#暴露6001端口作为微服务\n\nEXPOSE 6001\n</code></pre>\n<p>4.docker build -t cgc_docker:1.6</p>\n<p>5. 运行容器</p>\n<p>docker run -itd  -p 6001:6001 容器 ID</p>\n<p>6. 测试</p>\n<h3 id=\"100-docker网络\"><a class=\"markdownIt-Anchor\" href=\"#100-docker网络\">#</a> 10.0 Docker 网络</h3>\n<h4 id=\"1001常用命令\"><a class=\"markdownIt-Anchor\" href=\"#1001常用命令\">#</a> 10.0.1 常用命令</h4>\n<p>1. 查看 docker 网络模式命令</p>\n<p>docker network ls</p>\n<p>2. 查看所有命令</p>\n<p>docker network --help</p>\n<p>3. 查看网络源数据</p>\n<p>docker network inspect xxx 网络名字</p>\n<p>4. 删除网络</p>\n<p>docker network rm xxx 网络名字</p>\n<p>5. 创建网络</p>\n<p>docker network create 网络名字</p>\n<h4 id=\"1002-作用\"><a class=\"markdownIt-Anchor\" href=\"#1002-作用\">#</a> 10.0.2 作用</h4>\n<p>1. 容器的互联和通信以及端口映射</p>\n<p>2. 容器 IP 变动的时候可以通过服务名直接网络通信而不受到影像</p>\n<h4 id=\"1003-网络模式\"><a class=\"markdownIt-Anchor\" href=\"#1003-网络模式\">#</a> 10.0.3 网络模式</h4>\n<p>1.bridge 模式：使用–network bridge 指定，默认使用 docker0</p>\n<p>2.host 模式：使用–network host 指定</p>\n<p>3.none 模式：使用–network none 指定</p>\n<p>4.container 模式：使用–network container:NAME 或者容器 ID 指定</p>\n<p>docker 容器内部 ip 时有可能会发生改变的</p>\n<h5 id=\"10031-bridge\"><a class=\"markdownIt-Anchor\" href=\"#10031-bridge\">#</a> 10.0.3.1 bridge</h5>\n<p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为 docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</p>\n<p># 查看 bridge 网络的详细信息，并通过 grep 获取名称项</p>\n<p>docker network inspect bridge | grep name</p>\n<p>1 Docker 使用 Linux 桥接，在宿主机虚拟一个 Docker 容器网桥 (docker0)，Docker 启动一个容器时会根据 Docker 网桥的网段分配给容器一个 IP 地址，称为 Container-IP，同时 Docker 网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 直接通信。</p>\n<p>2 docker run 的时候，没有指定 network 的话默认使用的网桥模式就是 bridge，使用的就是 docker0。在宿主机 ifconfig, 就可以看到 docker0 和自己 create 的 network (后面讲) eth0，eth1，eth2…… 代表网卡一，网卡二，网卡三……，lo 代表 127.0.0.1，即 localhost，inet addr 用来表示网卡的 IP 地址</p>\n<p>3 网桥 docker0 创建一对对等虚拟设备接口一个叫 veth，另一个叫 eth0，成对匹配。</p>\n<p>3.1 整个宿主机的网桥模式都是 docker0，类似一个交换机有一堆接口，每个接口叫 veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫 veth pair）；</p>\n<p>3.2 每个容器实例内部也有一块网卡，每个接口叫 eth0；</p>\n<p>3.3 docker0 上面的每个 veth 匹配某个容器实例内部的 eth0，两两配对，一一匹配。</p>\n<p>通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下，会从这个网关下各自拿到分配的 ip，此时两个容器的网络是互通的。</p>\n<h5 id=\"10032-host\"><a class=\"markdownIt-Anchor\" href=\"#10032-host\">#</a> 10.0.3.2 host</h5>\n<p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行 NAT 转换。</p>\n<p>容器将不会获得一个独立的 Network Namespace， 而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的 IP 和端口。</p>\n<p>docker run -d  -p 8083:8083 --network host  --name …</p>\n<h5 id=\"10033-none\"><a class=\"markdownIt-Anchor\" href=\"#10033-none\">#</a> 10.0.3.3 none</h5>\n<p>禁用网络功能只有 lo 标识</p>\n<p>docker run -d  -p 8083:8083 --network none --name …</p>\n<h5 id=\"10034-container\"><a class=\"markdownIt-Anchor\" href=\"#10034-container\">#</a> 10.0.3.4 container</h5>\n<p>container ⽹络模式</p>\n<p>新建的容器和已经存在的一个容器共享一个网络 ip 配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p>\n<p>docker run -it --network container:alpine1 --name …</p>\n<h4 id=\"1011-docker-平台架构图解\"><a class=\"markdownIt-Anchor\" href=\"#1011-docker-平台架构图解\">#</a> 10.1.1 docker 平台架构图解</h4>\n<h5 id=\"10111整体说明\"><a class=\"markdownIt-Anchor\" href=\"#10111整体说明\">#</a> 10.1.1.1. 整体说明</h5>\n<p>从其架构和运行流程来看，Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。</p>\n<p>Docker 运行的基本流程为：</p>\n<p>1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p>\n<p>2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p>\n<p>3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p>\n<p>4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver 将下载镜像以 Graph 的形式存储。</p>\n<p>5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p>\n<p>6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</p>\n<p>7 Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作。</p>\n<h5 id=\"10112整体架构\"><a class=\"markdownIt-Anchor\" href=\"#10112整体架构\">#</a> 10.1.1.2. 整体架构</h5>\n<p><img data-src=\"/jiagou.png\" alt=\"\"></p>\n<p>​</p>\n<h3 id=\"110-docker-compose-容器编排\"><a class=\"markdownIt-Anchor\" href=\"#110-docker-compose-容器编排\">#</a> 11.0 Docker-compose 容器编排</h3>\n<h4 id=\"1101-是什么\"><a class=\"markdownIt-Anchor\" href=\"#1101-是什么\">#</a> 11.0.1 是什么？</h4>\n<p>Docker-Compose 是 Docker 官方的开源项目，负责实现对容器集群的快速编排</p>\n<h4 id=\"1102-能干什么\"><a class=\"markdownIt-Anchor\" href=\"#1102-能干什么\">#</a> 11.0.2 能干什么？</h4>\n<p>docker 建议我们每一个容器中只运行一个服务，因为 docker 容器本身占用资源极少，所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p>\n<p>如果我需要同时部署好多个服务，难道要每个服务单独写 Dockerfile 然后在构建镜像，构建容器，这样累都累死了，所以 docker 官方给我们提供了 docker-compose 多服务部署的工具</p>\n<p>例如要实现一个 Web 微服务项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库 mysql 服务容器，redis 服务器，注册中心 eureka，甚至还包括负载均衡容器等等。。。。。。</p>\n<p>Compose 允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>\n<p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p>\n<h4 id=\"1103-去哪里下载\"><a class=\"markdownIt-Anchor\" href=\"#1103-去哪里下载\">#</a> 11.0.3 去哪里下载？</h4>\n<p>下载：</p>\n<p>1.curl -L “<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9jb21wb3NlL3JlbGVhc2VzL2Rvd25sb2FkLzEuMjkuMi9kb2NrZXItY29tcG9zZS0=\">https://github.com/docker/compose/releases/download/1.29.2/docker-compose-</span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>−</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>−</mo></mrow><annotation encoding=\"application/x-tex\">(uname -s)-</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mord\">−</span></span></span></span>(uname -m)” -o /usr/local/bin/docker-compose</p>\n<p>2.chmod +x /usr/local/bin/docker-compose</p>\n<p>3.docker-compose --version</p>\n<p>卸载：</p>\n<p>sudo rm /usr/local/bin/docker-compose</p>\n<h4 id=\"1104-compose核心概念\"><a class=\"markdownIt-Anchor\" href=\"#1104-compose核心概念\">#</a> 11.0.4 Compose 核心概念</h4>\n<p>1. 一文件 docker-compose.yml</p>\n<p>2. 两要素</p>\n<p>（1）. 服务：一个个应用容器实例，比如订单微服务，库存微服务，mysql 容器。</p>\n<p>（2）. 工程：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p>\n<h4 id=\"1105-compose常用命令\"><a class=\"markdownIt-Anchor\" href=\"#1105-compose常用命令\">#</a> 11.0.5 Compose 常用命令</h4>\n<p><strong>Compose**** 常用命令</strong></p>\n<p>docker-compose -h              # 查看帮助</p>\n<p>docker-compose up              # 启动所有 docker-compose 服务</p>\n<p>docker-compose up -d             # 启动所有 docker-compose 服务并后台运行</p>\n<p>docker-compose down             # 停止并删除容器、网络、卷、镜像。</p>\n<p>docker-compose exec  yml 里面的服务 id         # 进入容器实例内部 docker-compose exec docker-compose.yml 文件中写的服务 id /bin/bash</p>\n<p>docker-compose ps            # 展示当前 docker-compose 编排过的运行的所有容器</p>\n<p>docker-compose top           # 展示当前 docker-compose 编排过的容器进程</p>\n<p>docker-compose logs  yml 里面的服务 id   # 查看容器输出日志</p>\n<p>docker-compose config   # 检查配置</p>\n<p>docker-compose config -q # 检查配置，有问题才有输出</p>\n<p>docker-compose restart  # 重启服务</p>\n<p>docker-compose start   # 启动服务</p>\n<p>docker-compose stop    # 停止服务</p>\n<h4 id=\"1106-compose使用的三个步骤\"><a class=\"markdownIt-Anchor\" href=\"#1106-compose使用的三个步骤\">#</a> 11.0.6 Compose 使用的三个步骤</h4>\n<p>1. 编写 Dockerfile 定义各个微服务应用并构建出对应的镜像文件</p>\n<p>2. 使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务</p>\n<p>3. 最后执行 docker-compose up 命令并启动运行整个应用程序，完成一键部署上线</p>\n<h4 id=\"1107-compose编排微服务\"><a class=\"markdownIt-Anchor\" href=\"#1107-compose编排微服务\">#</a> 11.0.7 Compose 编排微服务</h4>\n<p>1.package 把项目打包，放在与 docker-compose.yml 和 Dockerfile 同个目录下</p>\n<p>2. 编写 docker-compose.yml 文件</p>\n<pre><code>version: &quot;3&quot;\n\n \n\nservices:\n\n  microService:\n\n    image: zzyy_docker:1.6\n\n    container_name: ms01\n\n    ports:\n\n      - &quot;6001:6001&quot;\n\n    volumes:\n\n      - /app/microService:/data\n\n    networks: \n\n      - atguigu_net \n\n    depends_on: \n\n      - redis\n\n      - mysql\n\n \n\n  redis:\n\n    image: redis:6.0.8\n\n    ports:\n\n      - &quot;6379:6379&quot;\n\n    volumes:\n\n      - /app/redis/redis.conf:/etc/redis/redis.conf\n\n      - /app/redis/data:/data\n\n    networks: \n\n      - atguigu_net\n\n    command: redis-server /etc/redis/redis.conf\n\n \n\n  mysql:\n\n    image: mysql:5.7\n\n    environment:\n\n      MYSQL_ROOT_PASSWORD: '123456'\n\n      MYSQL_ALLOW_EMPTY_PASSWORD: 'no'\n\n      MYSQL_DATABASE: 'db2021'\n\n      MYSQL_USER: 'zzyy'\n\n      MYSQL_PASSWORD: 'zzyy123'\n\n    ports:\n\n       - &quot;3306:3306&quot;\n\n    volumes:\n\n       - /app/mysql/db:/var/lib/mysql\n\n       - /app/mysql/conf/my.cnf:/etc/my.cnf\n\n       - /app/mysql/init:/docker-entrypoint-initdb.d\n\n    networks:\n\n      - atguigu_net\n\n    command: --default-authentication-plugin=mysql_native_password #解决外部无法访问\n\n \n\nnetworks: \n\n   atguigu_net: \n</code></pre>\n<p>3. 编写 Dockerfile 文件</p>\n<pre><code># 基础镜像使用java\n\nFROM java:8\n\n# 作者\n\nMAINTAINER zzyy\n\n# VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp\n\nVOLUME /tmp\n\n# 将jar包添加到容器中并更名为zzyy_docker.jar\n\nADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar\n\n# 运行jar包\n\nRUN bash -c 'touch /zzyy_docker.jar'\n\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]\n\n#暴露6001端口作为微服务\n\nEXPOSE 6001\n</code></pre>\n<ol start=\"4\">\n<li>docker build -t zzyy_docker:1.6 .</li>\n<li>执行 docker-compose up 或者 docker-compose up -d</li>\n<li>关闭 docker-compose stop</li>\n</ol>\n<h3 id=\"130-docker-轻量级可视化工具portainer\"><a class=\"markdownIt-Anchor\" href=\"#130-docker-轻量级可视化工具portainer\">#</a> 13.0 Docker 轻量级可视化工具 Portainer</h3>\n<p>1. 是什么？</p>\n<p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理 Docker 环境，包括单机环境和集群环境。</p>\n<p>2. 安装</p>\n<p>（1）. 命令</p>\n<p>docker run -d -p 8000:8000 -p 9000:9000 --name portainer   --restart=always   -v /var/run/docker.sock:/var/run/docker.sock   -v portainer_data:/data   portainer/portainer</p>\n<p>（2）. 设置账号密码</p>\n<p>（3）. 地址 ip:9000</p>\n<h3 id=\"140-docker-容器监控之cadvisorinfluxdbgranfana\"><a class=\"markdownIt-Anchor\" href=\"#140-docker-容器监控之cadvisorinfluxdbgranfana\">#</a> 14.0 Docker 容器监控之 CAdvisor+InfluxDB+Granfana</h3>\n<p>1. 监控</p>\n<p>docker stats</p>\n<p>2.CAdvisor+InfluxDB+Granfana</p>\n<p><img data-src=\"C:%5CUsers%5C%E6%9B%B9%E9%AB%98%E5%9F%8E%5CDesktop%5Cdockerimages%5CCAdvisor.png\" alt=\"\"></p>\n<p><img data-src=\"C:%5CUsers%5C%E6%9B%B9%E9%AB%98%E5%9F%8E%5CDesktop%5Cdockerimages%5CInfluxDB.png\" alt=\"\"></p>\n<p><img data-src=\"C:%5CUsers%5C%E6%9B%B9%E9%AB%98%E5%9F%8E%5CDesktop%5Cdockerimages%5CGranfana.png\" alt=\"\"></p>\n<p>2. 创建 cig 文件夹，新建 docker-compose.yml</p>\n<pre><code>version: '3.1'\n\n \n\nvolumes:\n\n  grafana_data: &#123;&#125;\n\n \n\nservices:\n\n influxdb:\n\n  image: tutum/influxdb:0.9\n\n  restart: always\n\n  environment:\n\n    - PRE_CREATE_DB=cadvisor\n\n  ports:\n\n    - &quot;8083:8083&quot;\n\n    - &quot;8086:8086&quot;\n\n  volumes:\n\n    - ./data/influxdb:/data\n\n \n\n cadvisor:\n\n  image: google/cadvisor\n\n  links:\n\n    - influxdb:influxsrv\n\n  command: -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086\n\n  restart: always\n\n  ports:\n\n    - &quot;8080:8080&quot;\n\n  volumes:\n\n    - /:/rootfs:ro\n\n    - /var/run:/var/run:rw\n\n    - /sys:/sys:ro\n\n    - /var/lib/docker/:/var/lib/docker:ro\n\n \n\n grafana:\n\n  user: &quot;104&quot;\n\n  image: grafana/grafana\n\n  user: &quot;104&quot;\n\n  restart: always\n\n  links:\n\n    - influxdb:influxsrv\n\n  ports:\n\n    - &quot;3000:3000&quot;\n\n  volumes:\n\n    - grafana_data:/var/lib/grafana\n\n  environment:\n\n    - HTTP_USER=admin\n\n    - HTTP_PASS=admin\n\n    - INFLUXDB_HOST=influxsrv\n\n    - INFLUXDB_PORT=8086\n\n    - INFLUXDB_NAME=cadvisor\n\n    - INFLUXDB_USER=root\n\n    - INFLUXDB_PASS=root\n</code></pre>\n<p>3.docker-compose up</p>\n<ol start=\"4\">\n<li></li>\n</ol>\n<p>（1）. 浏览 cAdvisor 收集服务 <span class=\"exturl\" data-url=\"aHR0cDovL2lwOjgwODA=\">http://ip:8080</span></p>\n<p>（2）. 浏览 influxdb 存储服务 <span class=\"exturl\" data-url=\"aHR0cDovL2lwOjgwODM=\">http://ip:8083</span></p>\n<p>（3）. 浏览 grafana 展现服务  <span class=\"exturl\" data-url=\"aHR0cDovL2lwOjMwMDA=\">http://ip:3000</span></p>\n",
            "tags": [
                "Docker"
            ]
        },
        {
            "id": "https://hahayixiao2.github.io/computer-science/container/DockerCompose%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/dockercompose/",
            "url": "https://hahayixiao2.github.io/computer-science/container/DockerCompose%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/dockercompose/",
            "title": "dockercompose笔记",
            "date_published": "2022-05-02T12:56:48.000Z",
            "content_html": "<h1 id=\"docker-compose入门学习\"><a class=\"markdownIt-Anchor\" href=\"#docker-compose入门学习\">#</a> Docker Compose 入门学习</h1>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h2>\n<p>我们之前操作 Docker 的过程是：DockerFile  build run 进行手动操作，单个容器，如果假设我们有 100 个微服务，并行微服务之间还存在依赖关系。这个时候，我们就可以使用 Docker Compose 来轻松高效的管理容器，定义运行多个容器。</p>\n<h3 id=\"官方介绍\"><a class=\"markdownIt-Anchor\" href=\"#官方介绍\">#</a> 官方介绍：</h3>\n<ul>\n<li>定义、运行多个容器</li>\n<li>YAML file 配置环境</li>\n</ul>\n<blockquote>\n<p>Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。使用 Compose，您可以使用 YAML 文件来配置应用程序的服务。然后，使用一个命令，就可以从配置中创建并启动所有服务。要了解有关 Compose 的所有特性的更多信息，请参阅<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS8jZmVhdHVyZXM=\">特性列表</span>。</p>\n<p>Compose 可以在所有环境中工作：生产、阶段、开发、测试，以及 CI 工作流。您可以在常见用例中了解关于每个用例的更多信息</p>\n<p>使用 Compose 基本上有三个步骤:</p>\n<ul>\n<li>用 Dockerfile 定义你的应用程序的环境，这样它就可以在任何地方复制。</li>\n<li>在 Docker-compose 中定义组成应用程序的服务。这样它们就可以在一个独立的环境中一起运行。</li>\n<li>运行 docker-compose up 和 Compose 启动并运行整个应用程序。</li>\n</ul>\n</blockquote>\n<h3 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\">#</a> 作用</h3>\n<p>批量容器编排</p>\n<blockquote>\n<p>Compose 是 Docker 官方的开源项目，需要安装！</p>\n<p>Dockerfile 让程序在任何地方运行，web 服务。Redis、MySQL、Nginx。。。多个容器</p>\n</blockquote>\n<p>Compose 的 YAML 文件如下所示</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'2.0'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> .</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">-</span> <span class=\"token string\">\"5000:5000\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">-</span> .<span class=\"token punctuation\">:</span>/code</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">-</span> logvolume01<span class=\"token punctuation\">:</span>/var/log</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token key atrule\">links</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">-</span> redis</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> redis</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token key atrule\">logvolume01</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>docker-compose up 100 个服务，也可以一键启动</p>\n<p>Compose：重要的概念</p>\n<ul>\n<li>服务 service，容器，应用（web，redis，mysql）</li>\n<li>项目 project，就是一组关联的容器。</li>\n</ul>\n<h2 id=\"常见的docker-compose脚本\"><a class=\"markdownIt-Anchor\" href=\"#常见的docker-compose脚本\">#</a> 常见的 Docker Compose 脚本</h2>\n<p>下面这个是小伙伴开源的一些 Docker Compose 脚本，我们如果需要部署某个应用的时候，可以通过下面脚本，非常方便的进行部署</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vemhlbmdxaW5neWEvZG9ja2VyLWNvbXBvc2U=\">https://gitee.com/zhengqingya/docker-compose</span></p>\n<h2 id=\"安装docker-compose\"><a class=\"markdownIt-Anchor\" href=\"#安装docker-compose\">#</a> 安装 Docker Compose</h2>\n<p>官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9pbnN0YWxsLw==\">https://docs.docker.com/compose/install/</span></p>\n<h3 id=\"下载\"><a class=\"markdownIt-Anchor\" href=\"#下载\">#</a> 下载</h3>\n<p>首先我们先安装一下 Docker</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># yum 安装</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>yum -y <span class=\"token function\">install</span> docker-ce</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">#查看 docker 版本</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">docker</span> --version  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 设置开机自启</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>systemctl <span class=\"token builtin class-name\">enable</span> <span class=\"token function\">docker</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 启动 docker</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>systemctl start <span class=\"token function\">docker</span></pre></td></tr></table></figure><p>然后下载 docker-compose</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">curl</span> -L <span class=\"token string\">\"https://github.com/docker/compose/releases/download/1.26.2/docker-compose-<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">uname</span> -s<span class=\"token variable\">)</span></span>-<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">uname</span> -m<span class=\"token variable\">)</span></span>\"</span> -o /usr/local/bin/docker-compose</pre></td></tr></table></figure><h3 id=\"授权\"><a class=\"markdownIt-Anchor\" href=\"#授权\">#</a> 授权</h3>\n<p>下载完成后，我们进入到下面的目录</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /usr/local/bin</pre></td></tr></table></figure><p>然后加入执行权限</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> +x <span class=\"token function\">docker-compose</span></pre></td></tr></table></figure><p>查看是否安装成功</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker-compose</span> version</pre></td></tr></table></figure><h3 id=\"创建文件体验\"><a class=\"markdownIt-Anchor\" href=\"#创建文件体验\">#</a> 创建文件体验</h3>\n<p>在这个页面中，您将构建一个运行在 Docker 撰写器上的简单 Python web 应用程序。该应用程序使用了烧瓶框架，并在 Redis 中维护了一个命中计数器。虽然示例使用 Python，但是即使您不熟悉它，这里演示的概念也应该可以理解。</p>\n<p>确保你已经安装了 Docker 引擎和 Docker 组合。你不需要安装 Python 或 Redis，因为它们都是由 Docker images 提供的。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 创建文件夹</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">mkdir</span> composetest</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 进入该文件夹</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">cd</span> composetest</pre></td></tr></table></figure><p>然后我们需要创建一个 <span class=\"exturl\" data-url=\"aHR0cDovL2FwcC5weQ==\">app.py</span> 文件</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">import</span> <span class=\"token function\">time</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">import</span> redis</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>from flask <span class=\"token function\">import</span> Flask</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>app <span class=\"token operator\">=</span> Flask<span class=\"token punctuation\">(</span>__name__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>cache <span class=\"token operator\">=</span> redis.Redis<span class=\"token punctuation\">(</span>host<span class=\"token operator\">=</span><span class=\"token string\">'redis'</span>, <span class=\"token assign-left variable\">port</span><span class=\"token operator\">=</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>def get_hit_count<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>:</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    retries <span class=\"token operator\">=</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">while</span> True:</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        try:</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token builtin class-name\">return</span> cache.incr<span class=\"token punctuation\">(</span><span class=\"token string\">'hits'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        except redis.exceptions.ConnectionError as exc:</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token keyword\">if</span> retries <span class=\"token operator\">==</span> <span class=\"token number\">0</span>:</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                raise exc</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            retries -<span class=\"token operator\">=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            time.sleep<span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>@app.route<span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>def hello<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>:</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    count <span class=\"token operator\">=</span> get_hit_count<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token builtin class-name\">return</span> <span class=\"token string\">'Hello World! I have been seen &#123;&#125; times.\\n'</span>.format<span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>然后创建一个 requirements.txt 文件，里面需要依赖包</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>flask</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>redis</pre></td></tr></table></figure><h3 id=\"创建docker-file\"><a class=\"markdownIt-Anchor\" href=\"#创建docker-file\">#</a> 创建 Docker file</h3>\n<p>在这个步骤中，您将编写一个构建 Docker 映像的 Dockerfile。该映像包含 Python 应用程序需要的所有依赖项，包括 Python 本身。在您的项目目录中，创建一个名为 Dockerfile 的文件，并粘贴以下内容:</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FROM python:3.7-alpine</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>WORKDIR /code</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>ENV FLASK_APP app.py</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>ENV FLASK_RUN_HOST <span class=\"token number\">0.0</span>.0.0</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>RUN apk <span class=\"token function\">add</span> --no-cache gcc musl-dev linux-headers</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>COPY requirements.txt requirements.txt</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>RUN pip <span class=\"token function\">install</span> -r requirements.txt</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>EXPOSE <span class=\"token number\">5000</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>COPY <span class=\"token builtin class-name\">.</span> <span class=\"token builtin class-name\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>CMD <span class=\"token punctuation\">[</span><span class=\"token string\">\"flask\"</span>, <span class=\"token string\">\"run\"</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><blockquote>\n<p>上述代码中，是为了告诉 Docker</p>\n<p>从 Python3.7 版本开始构建镜像</p>\n<p>将当前目录设置为 /code</p>\n<p>安装 python 依赖项</p>\n<p>将容器的默认命令设置为 python <span class=\"exturl\" data-url=\"aHR0cDovL2FwcC5weQ==\">app.py</span></p>\n</blockquote>\n<h3 id=\"定义服务在compose文件中\"><a class=\"markdownIt-Anchor\" href=\"#定义服务在compose文件中\">#</a> 定义服务在 Compose 文件中</h3>\n<p>创建一个名为 docker-compose 的文件。yml 在您的项目目录，并粘贴以下</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>version: <span class=\"token string\">'3'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>services:</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  web:</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    build: <span class=\"token builtin class-name\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    ports:</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      - <span class=\"token string\">\"5000:5000\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  redis:</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    image: <span class=\"token string\">\"redis:alpine\"</span></pre></td></tr></table></figure><blockquote>\n<p>此 Compose 文件定义了两个服务，web 和 redis，该 web 服务使用从 Docker file 当前目录中构建的镜像</p>\n<p>将容器上的公开端口 5000</p>\n</blockquote>\n<p>这个合成文件定义了两个服务:web 和 redis。</p>\n<h4 id=\"web服务\"><a class=\"markdownIt-Anchor\" href=\"#web服务\">#</a> Web 服务</h4>\n<p>web 服务使用从当前目录中的 Dockerfile 构建的映像。然后，它将容器和主机绑定到公开的端口 5000。这个示例服务使用了 Flask web 服务器 5000 的默认端口</p>\n<h4 id=\"redis服务\"><a class=\"markdownIt-Anchor\" href=\"#redis服务\">#</a> Redis 服务</h4>\n<p>redis 服务使用从 Docker Hub 注册中心提取的公共 redis 图像</p>\n<h3 id=\"使用compose构建和运行应用程序\"><a class=\"markdownIt-Anchor\" href=\"#使用compose构建和运行应用程序\">#</a> 使用 Compose 构建和运行应用程序</h3>\n<p>在项目目录中，通过运行启动应用程序   <code>docker-compose up</code> .</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker-compose</span> up</pre></td></tr></table></figure><p>运行结果如下</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Creating network <span class=\"token string\">\"composetest_default\"</span> with the default driver</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Creating composetest_web_1 <span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Creating composetest_redis_1 <span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Creating composetest_web_1</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>Creating composetest_redis_1 <span class=\"token punctuation\">..</span>. <span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Attaching to composetest_web_1, composetest_redis_1</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>web_1    <span class=\"token operator\">|</span>  * Running on http://0.0.0.0:5000/ <span class=\"token punctuation\">(</span>Press CTRL+C to quit<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>redis_1  <span class=\"token operator\">|</span> <span class=\"token number\">1</span>:C <span class=\"token number\">17</span> Aug <span class=\"token number\">22</span>:11:10.480 <span class=\"token comment\"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>redis_1  <span class=\"token operator\">|</span> <span class=\"token number\">1</span>:C <span class=\"token number\">17</span> Aug <span class=\"token number\">22</span>:11:10.480 <span class=\"token comment\"># Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just started</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>redis_1  <span class=\"token operator\">|</span> <span class=\"token number\">1</span>:C <span class=\"token number\">17</span> Aug <span class=\"token number\">22</span>:11:10.480 <span class=\"token comment\"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>web_1    <span class=\"token operator\">|</span>  * Restarting with <span class=\"token function\">stat</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>redis_1  <span class=\"token operator\">|</span> <span class=\"token number\">1</span>:M <span class=\"token number\">17</span> Aug <span class=\"token number\">22</span>:11:10.483 * Running <span class=\"token assign-left variable\">mode</span><span class=\"token operator\">=</span>standalone, <span class=\"token assign-left variable\">port</span><span class=\"token operator\">=</span><span class=\"token number\">6379</span>.</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>redis_1  <span class=\"token operator\">|</span> <span class=\"token number\">1</span>:M <span class=\"token number\">17</span> Aug <span class=\"token number\">22</span>:11:10.483 <span class=\"token comment\"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>web_1    <span class=\"token operator\">|</span>  * Debugger is active<span class=\"token operator\">!</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>redis_1  <span class=\"token operator\">|</span> <span class=\"token number\">1</span>:M <span class=\"token number\">17</span> Aug <span class=\"token number\">22</span>:11:10.483 <span class=\"token comment\"># Server initialized</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>redis_1  <span class=\"token operator\">|</span> <span class=\"token number\">1</span>:M <span class=\"token number\">17</span> Aug <span class=\"token number\">22</span>:11:10.483 <span class=\"token comment\"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>web_1    <span class=\"token operator\">|</span>  * Debugger PIN: <span class=\"token number\">330</span>-787-903</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>redis_1  <span class=\"token operator\">|</span> <span class=\"token number\">1</span>:M <span class=\"token number\">17</span> Aug <span class=\"token number\">22</span>:11:10.483 * Ready to accept connections</pre></td></tr></table></figure><p>最后查看服务是否启动成功</p>\n<p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20200727212451516.png\" alt=\"image-20200727212451516\"></p>\n<p>使用 docker images 命令，我们发现在 docker compose 中的镜像都已经下载好了</p>\n<p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20200727212555232.png\" alt=\"image-20200727212555232\"></p>\n<h3 id=\"网络规则\"><a class=\"markdownIt-Anchor\" href=\"#网络规则\">#</a> 网络规则</h3>\n<p>使用下面的命令，就可以查看到 docker 中的网络</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> network <span class=\"token function\">ls</span></pre></td></tr></table></figure><p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20200727212932704.png\" alt=\"image-20200727212932704\"></p>\n<p>通过 compose 构建的服务，compose 帮我们维护了，都会在一个网络下面，就可以通过域名访问</p>\n<p>我们通过以下命令来进行查看，发现启动的两个服务，就是同处于同一个网络下的</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> network inspect composetest_default</pre></td></tr></table></figure><p><img data-src=\"https://cgc-blog.oss-cn-beijing.aliyuncs.com/container/docker/image-20200727213527466.png\" alt=\"image-20200727213527466\"></p>\n<h3 id=\"关闭docker-compose\"><a class=\"markdownIt-Anchor\" href=\"#关闭docker-compose\">#</a> 关闭 docker compose</h3>\n<p>可以使用一下命令退出</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker-compose</span> down</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 或者</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>ctrl + c</pre></td></tr></table></figure><h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>我们可以对上述的操作，进行一下总结，就可以分为一下几个步骤</p>\n<ul>\n<li>应用 <span class=\"exturl\" data-url=\"aHR0cDovL2FwcC5weQ==\">app.py</span></li>\n<li>Docker file  将应用程序打包成镜像</li>\n<li>Docker-compose yaml 文件（定义整个服务，需要的环境，web、redis）完整的上线服务</li>\n<li>启动 compose 项目（docker-compose up）</li>\n<li>流程\n<ul>\n<li>创建网络</li>\n<li>执行 Docker-compose yaml</li>\n<li>启动服务</li>\n</ul>\n</li>\n</ul>\n<p>原来我们没有用到 docker-compose 的时候，都是需要使用 docker run，一个个的运行我们的容器</p>\n<p>通过 docker-compose，我们编写 yaml 文件，可以通过 docker-compose 一键启动服务，或者停止。</p>\n<h2 id=\"yaml规则\"><a class=\"markdownIt-Anchor\" href=\"#yaml规则\">#</a> yaml 规则</h2>\n<p>docker-compose.yaml 规则</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 三层</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>version: <span class=\"token string\">\"3.8\"</span>  <span class=\"token comment\"># 定义版本</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>services:       <span class=\"token comment\"># 定义服务</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   服务1:web</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>       images</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>       build</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>       network</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t   <span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   服务2:redis</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   \t\t<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   服务3:nginx</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>   \t\t<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token comment\"># 其它配置 网络 / 卷、全局规则</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  volumes:</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  networks:</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  configs:</pre></td></tr></table></figure><p>完整实例如下</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3.8\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> redis<span class=\"token punctuation\">:</span>latest</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">configs</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>      <span class=\"token punctuation\">-</span> my_config</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>      <span class=\"token punctuation\">-</span> my_other_config</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token key atrule\">configs</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token key atrule\">my_config</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token key atrule\">file</span><span class=\"token punctuation\">:</span> ./my_config.txt</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token key atrule\">my_other_config</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token key atrule\">external</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></pre></td></tr></table></figure><h3 id=\"依赖关系\"><a class=\"markdownIt-Anchor\" href=\"#依赖关系\">#</a> 依赖关系</h3>\n<p>如果我们的项目还有依赖关系，比如  web 依赖于 redis，也就是说项目需要首先启动 redis</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3.8\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> .</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token punctuation\">-</span> db</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>      <span class=\"token punctuation\">-</span> redis</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> redis</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token key atrule\">db</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> postgres</pre></td></tr></table></figure><h2 id=\"快速搭建wordpress\"><a class=\"markdownIt-Anchor\" href=\"#快速搭建wordpress\">#</a> 快速搭建 WordPress</h2>\n<p>官网搭建文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS93b3JkcHJlc3Mv\">https://docs.docker.com/compose/wordpress/</span></p>\n<p>首先创建项目的文件夹</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 创建文件夹</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">mkdir</span> my_wordpress</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 进入文件夹</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">cd</span> my_wordpress/</pre></td></tr></table></figure><p>然后创建一个 docker-compose.yml 文件</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3.3'</span> <span class=\"token comment\"># 定义版本</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token key atrule\">db</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mysql<span class=\"token punctuation\">:</span><span class=\"token number\">5.7</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>       <span class=\"token punctuation\">-</span> db_data<span class=\"token punctuation\">:</span>/var/lib/mysql</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> always</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>       <span class=\"token key atrule\">MYSQL_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> somewordpress</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>       <span class=\"token key atrule\">MYSQL_DATABASE</span><span class=\"token punctuation\">:</span> wordpress</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>       <span class=\"token key atrule\">MYSQL_USER</span><span class=\"token punctuation\">:</span> wordpress</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>       <span class=\"token key atrule\">MYSQL_PASSWORD</span><span class=\"token punctuation\">:</span> wordpress</pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>   <span class=\"token key atrule\">wordpress</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>     <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 依赖于上一个 db，也就是需要 db 启动</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>       <span class=\"token punctuation\">-</span> db</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>     <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> wordpress<span class=\"token punctuation\">:</span>latest</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>     <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>       <span class=\"token punctuation\">-</span> <span class=\"token string\">\"8000:80\"</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>     <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> always</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>     <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>       <span class=\"token key atrule\">WORDPRESS_DB_HOST</span><span class=\"token punctuation\">:</span> db<span class=\"token punctuation\">:</span><span class=\"token number\">3306</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>       <span class=\"token key atrule\">WORDPRESS_DB_USER</span><span class=\"token punctuation\">:</span> wordpress</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>       <span class=\"token key atrule\">WORDPRESS_DB_PASSWORD</span><span class=\"token punctuation\">:</span> wordpress</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>       <span class=\"token key atrule\">WORDPRESS_DB_NAME</span><span class=\"token punctuation\">:</span> wordpress</pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token key atrule\">db_data</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>后台启动项目</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker-compose</span>  -d</pre></td></tr></table></figure><p>到此为止，项目已经成功搭建完毕</p>\n<blockquote>\n<p>正常的开源项目，可能还需要依赖 build 后的 jar 包，所以我们还需要使用 Dockerfile</p>\n<p>当我们的文件准备齐全的时候，就可以一键启动项目</p>\n</blockquote>\n<p>未来的趋势：linux、docker、k8s</p>\n<p>掌握：docker 基础、原理、网络、服务、集群、错误排查、日志。</p>\n<h2 id=\"docker-compose搭建微服务\"><a class=\"markdownIt-Anchor\" href=\"#docker-compose搭建微服务\">#</a> docker-compose 搭建微服务</h2>\n<p>我们可以使用下面命令 ，创建一个 SpringBoot 项目：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFydC5zcHJpbmcuaW8v\">https://start.spring.io/</span></p>\n<ul>\n<li>编写项目微服务</li>\n<li>dockerfile 构建镜像</li>\n<li>创建 docker-compose 来启动项目，进行服务编排</li>\n<li>丢到服务器 docker-compose 启动</li>\n<li>如果出现了问题：使用 docker-compose up  --build（重新构建）</li>\n</ul>\n<h2 id=\"docker小结\"><a class=\"markdownIt-Anchor\" href=\"#docker小结\">#</a> Docker 小结</h2>\n<ul>\n<li>Docker 镜像 -&gt; 通过 run 命令启动镜像</li>\n<li>Dockerfile 构建镜像（服务打包）</li>\n<li>docker-compose 启动项目（编排、多个微服务 / 环境）</li>\n<li>Docker 网络</li>\n</ul>\n<h2 id=\"参考\"><a class=\"markdownIt-Anchor\" href=\"#参考\">#</a> 参考</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWt2NDExcTdRYw==\">https://www.bilibili.com/video/BV1kv411q7Qc</span></p>\n",
            "tags": [
                "Docker"
            ]
        }
    ]
}