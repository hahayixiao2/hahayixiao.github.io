



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/hahayixiao2/hahayixiao2.github.io@latest/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/hahayixiao2/hahayixiao2.github.io@latest/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="一个小萌新的进阶之路" href="https://hahayixiao2.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="一个小萌新的进阶之路" href="https://hahayixiao2.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="一个小萌新的进阶之路" href="https://hahayixiao2.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/hahayixiao2/hahayixiao2.github.io@latest/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="Docker" />


<link rel="canonical" href="https://hahayixiao2.github.io/computer-science/container/Docker/docker/">



  <title>
docker笔记 - 容器 - 计算机 |
HaHaYiXiao = 一个小萌新的进阶之路</title>
<meta name="generator" content="Hexo 6.1.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">docker笔记
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2022-05-02 20:56:48">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2022-05-02T20:56:48+08:00">2022-05-02</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">HaHaYiXiao</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclfdu6exj20zk0m87hw.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclimtf7dj20zk0m8qav.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机"><span itemprop="name">计算机</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/container/" itemprop="item" rel="index" title="分类于 容器"><span itemprop="name">容器</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://hahayixiao2.github.io/computer-science/container/Docker/docker/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="//cdn.jsdelivr.net/gh/hahayixiao2/hahayixiao2.github.io@latest/images/avatar.png">
    <meta itemprop="name" content="hahayixiao">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一个小萌新的进阶之路">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h2 id="docker"><a class="markdownIt-Anchor" href="#docker">#</a> docker</h2>
<h3 id="10-docker-安装步骤"><a class="markdownIt-Anchor" href="#10-docker-安装步骤">#</a> 1.0 docker 安装步骤</h3>
<p><img data-src="/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B.png" alt="安装流程"></p>
<p>运行 docker run hello-world 能出现这个说明 docker 已经安装成功了！</p>
<h4 id="101-docker-配置阿里云加速"><a class="markdownIt-Anchor" href="#101-docker-配置阿里云加速">#</a> 1.0.1 docker 配置阿里云加速</h4>
<p>登录阿里云 -&gt; 选择容器镜像服务 -&gt; 选择镜像加速器</p>
<p>共有 ubuntu，centos，mac，windows 版本</p>
<p>centos 配置</p>
<pre><code class="language-linux">sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
&#123;
  &quot;registry-mirrors&quot;: [&quot;https://scg3prw2.mirror.aliyuncs.com&quot;]
&#125;
EOF
sudo systemctl daemon-reload
sudo systemctl restart docke2.r
</code></pre>
<h3 id="20-docker常用命令"><a class="markdownIt-Anchor" href="#20-docker常用命令">#</a> 2.0 docker 常用命令</h3>
<h4 id="201-帮助启动类命令"><a class="markdownIt-Anchor" href="#201-帮助启动类命令">#</a> 2.0.1 帮助启动类命令</h4>
<pre><code>1. 启动docker ：systemctl start docker
2. 停止docker ：systemctl stop docker
3. 重启docker：systemctl restart docker
4. 查看docker状态：systemctl status docker
5. 开机启动：systemctl enable docker
6. 查看docker概要信息：docker --info
7. 查看docker总体帮助文档：docker --help
8. 查看docker命令帮助文档：docker具体命令 --help
</code></pre>
<h4 id="202-镜像命令"><a class="markdownIt-Anchor" href="#202-镜像命令">#</a> 2.0.2 镜像命令</h4>
<h5 id="2021-显示已有镜像"><a class="markdownIt-Anchor" href="#2021-显示已有镜像">#</a> 2.0.2.1 显示已有镜像</h5>
<p>列出本地主机上面的镜像</p>
<p>![](/docker images.jpg)</p>
<p>如图所示：</p>
<p>REPOSITORY：表示镜像的仓库源</p>
<p>TAG: 表示镜像的标签（版本号）</p>
<p>IMAGE ID: 镜像 ID</p>
<p>CREATED: 镜像创建的时间</p>
<p>SIZE: 镜像的大小</p>
<p>同一个仓库源可以有多个 tag（版本号），使用 REPOSITORY:TAG 来定义不同的镜像，如果不指定则默认使用最新版本如 mysql:latest 镜像</p>
<p>-options 操作说明：</p>
<ol>
<li>-a：列出本地的所有镜像 (含历史)</li>
<li>-q：只显示镜像 ID</li>
</ol>
<h5 id="2022-从仓库查找镜像"><a class="markdownIt-Anchor" href="#2022-从仓库查找镜像">#</a> 2.0.2.2 从仓库查找镜像</h5>
<p>![](/docker search.jpg)</p>
<p>NAME：镜像名称</p>
<p>DESCRIPTION: 镜像说明</p>
<p>STARTS: 点赞数量</p>
<p>OFFICIAL: 是否为官方的</p>
<p>AUTOMATED: 是否是自动构建的</p>
<p>-option 操作说明：</p>
<p>–limit ：只列出 N 个镜像，默认 25 个 （docker search --limit 5 redis）</p>
<h5 id="2023-下载镜像"><a class="markdownIt-Anchor" href="#2023-下载镜像">#</a> 2.0.2.3 下载镜像</h5>
<p>![](/docker pull.png)</p>
<p>下载镜像</p>
<p>1.docker pull 镜像名字 [:TAG]</p>
<p>2.docker pull 镜像名字</p>
<p>(1). 没有 TAG 就是最新版 = docker pull 镜像名字:latest</p>
<h5 id="2024-查看docker资源占用情况"><a class="markdownIt-Anchor" href="#2024-查看docker资源占用情况">#</a> 2.0.2.4 查看 docker 资源占用情况</h5>
<p>docker system df</p>
<p>![](/docker system df.png)</p>
<h5 id="2025-删除镜像"><a class="markdownIt-Anchor" href="#2025-删除镜像">#</a> 2.0.2.5  删除镜像</h5>
<p>![](/docker rmi.png)</p>
<p>1.docker rmi -f 镜像 id（删除单个)</p>
<p>2.docker rmi -f 镜像名 1:tag 镜像名 2:tag (删除多个)</p>
<p>3.docker rmi -f $(docker images -qa) （删除全部）</p>
<h5 id="2026-启动交互式容器"><a class="markdownIt-Anchor" href="#2026-启动交互式容器">#</a> 2.0.2.6 启动交互式容器</h5>
<p>docker run（前台命令行）</p>
<p>–name =“容器的新名字”</p>
<p>-d：后台运行容器并且返回容器 id，也即启动守护式容器（后台运行）；</p>
<p>-i：以交互模式运行容器，通常与 - t 同时使用，</p>
<p>-t：为容器分配一个伪输入终端，通常与 - i 一起使用，也即启动交互式容器（前台有伪终端，等待交互）</p>
<p>-P：随机端口映射，大写 P</p>
<p>-p：指定端口映射，小写 p</p>
<p>![image-20220201150011636](/docker run.png)</p>
<h5 id="2027-查看容器"><a class="markdownIt-Anchor" href="#2027-查看容器">#</a> 2.0.2.7 查看容器</h5>
<p>docker ps</p>
<p>-a: 列出所有正在运行的容器</p>
<p>-l：显示最近创建的容器</p>
<p>-n: 显示最近 n 个创建的容器</p>
<p>-q：静默模式，只显示容器编号</p>
<h5 id="2028-退出容器"><a class="markdownIt-Anchor" href="#2028-退出容器">#</a> 2.0.2.8 退出容器</h5>
<p>（1）.exit： run 进去容器，exit 退出，容器停止</p>
<p>（2）.ctrl+p+q run 进去容器，ctrl+p+q 退出，容器不停止<img data-src="" alt=""></p>
<h5 id="2029-启动容器"><a class="markdownIt-Anchor" href="#2029-启动容器">#</a> 2.0.2.9 启动容器</h5>
<p>（1）.docker start 容器 ID 或者容器名</p>
<h5 id="20210-停止容器"><a class="markdownIt-Anchor" href="#20210-停止容器">#</a> 2.0.2.10 停止容器</h5>
<p>（1）.docker stop 容器 ID 或者容器名</p>
<h5 id="20211-重启容器"><a class="markdownIt-Anchor" href="#20211-重启容器">#</a> 2.0.2.11 重启容器</h5>
<p>（1）.docker restart 容器 ID 或者容器名</p>
<h5 id="20212-强制停止容器"><a class="markdownIt-Anchor" href="#20212-强制停止容器">#</a> 2.0.2.12 强制停止容器</h5>
<p>（1）.docker kill 容器 ID 或者容器名</p>
<h5 id="20213-删除已停止的容器"><a class="markdownIt-Anchor" href="#20213-删除已停止的容器">#</a> 2.0.2.13 删除已停止的容器</h5>
<p>（1）.docker rm 容器 ID</p>
<p>（2）.dockers 删除多个容器</p>
<p>​        1.docker rm -f (docker ps -a -q)</p>
<p>​        2.docker ps -a -q |xagrs docker rm</p>
<h5 id="20214-查看日志"><a class="markdownIt-Anchor" href="#20214-查看日志">#</a> 2.0.2.14 查看日志</h5>
<p>docker logs 容器 ID</p>
<h5 id="20215-查看容器内运行的进程"><a class="markdownIt-Anchor" href="#20215-查看容器内运行的进程">#</a> 2.0.2.15 查看容器内运行的进程</h5>
<p>docker top 容器 ID</p>
<h5 id="20216-重新进入终端"><a class="markdownIt-Anchor" href="#20216-重新进入终端">#</a> 2.0.2.16 重新进入终端</h5>
<p>（1）.docker exec -it 容器 ID /bin/bash  (bash)（推荐使用）</p>
<p>exec 是在容器中打开新的终端，并且可以启动新的进程，用 exit 退出不会导致容器的停止。</p>
<p>（2）.docker attach 容器 ID</p>
<p>attach 直接进入容器启动命令的终端，不会启动新的进程，用 exit 退出会导致容器的停止。</p>
<h5 id="20217-拷贝文件"><a class="markdownIt-Anchor" href="#20217-拷贝文件">#</a> 2.0.2.17 拷贝文件</h5>
<p>docker cp 容器 ID: 容器内的路径 目标主机的地址</p>
<h5 id="20218-导入和导出容器"><a class="markdownIt-Anchor" href="#20218-导入和导出容器">#</a> 2.0.2.18 导入和导出容器</h5>
<p>导出：docker export 容器 ID &gt; 文件名.tar</p>
<p>导入：cat 文件名.tar | docker import - 镜像用户 / 镜像名：镜像版本号</p>
<h3 id="30-docker-镜像"><a class="markdownIt-Anchor" href="#30-docker-镜像">#</a> 3.0 docker 镜像</h3>
<p>1. 是一种轻量级，可执行的独立软件包，它包含运行某个软件所需要的所有内容，我们把应用程序和配置依赖打包好形成一个可以交付的运行环境 (包括代码，运行时需要的库，环境变量和配置文件等)，这个打包好的运行环境就是 image 的镜像文件</p>
<p>只有通过这个镜像文件才能生成 Docker 容器实例（类似 Java 中 new 出来的一个对象)</p>
<p>2. 联合文件系统 UnionFS:Union 文件系统（UnionFS）是一种分层，轻量级并且高新能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<p>3.docker 镜像分层最大的一个好处就是为了资源共享，方便复制迁移，就是为了复用。</p>
<p>docker commit 提交容器副本使之成为一个新的镜像</p>
<p>docker commit -m=“提交的描述信息” -a=“作者” 容器 ID 要创建的目标镜像名：[标签名]</p>
<h3 id="40-docker-容器数据卷"><a class="markdownIt-Anchor" href="#40-docker-容器数据卷">#</a> 4.0 docker 容器数据卷</h3>
<p>（1）. 是什么？</p>
<p>1.Docker 挂载主机目录访问如果出现 cannnot open directory .: Permission denied</p>
<p>解决办法：在挂载目录后多加一个–privileged=true 参数即可</p>
<p>2. 卷就是目录或者文件，存在于一个或者多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System 提供一些用于持续储存或者共享数据的特性。</p>
<p>卷的设计目的就是数据持久化，完全的独立于容器的生存周期，因此 Docker 不会在容器删除的时候删除其挂载的数据卷</p>
<p>（2）. 能干什么？</p>
<p>1. 将运用与运行的环境打包成镜像，run 后形成容器实例运行，但是我们对数据的要求希望是持久化的</p>
<p>Docker 容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p>
<p>为了能保存数据在 docker 中我们使用卷。</p>
<p>特点：</p>
<p>1. 数据卷在容器之间共享或重用数据</p>
<p>2. 卷中的更改可以直接实时生效</p>
<p>3. 数据卷中的更改不会包含在镜像的更新中</p>
<p>4. 数据卷的生命周期一直持续到没有容器使用它为止</p>
<p>（3）. 案例</p>
<p>1.docker run -it --privileged=true -v / 宿主机绝对路径目录:/ 容器内目录  镜像名     (如果没有目录 docker 自建)</p>
<p>2. 查看数据卷是否挂载成功 docker inspect 容器 ID</p>
<p>3. 容器内的目录可读可写 docker run -it --privileged=true -v / 宿主机绝对路径目录:/ 容器内目录:rw  镜像名</p>
<p>4. 容器内只能读不能写 docker run -it --privileged=true -v / 宿主机绝对路径目录:/ 容器内目录:ro 镜像名</p>
<p>（4）. 卷的继承和共享</p>
<p>1.docker run  -it --privileged=true --volumes-from 父类 --name u2 ubuntu</p>
<h3 id="50-docker-常规软件的安装"><a class="markdownIt-Anchor" href="#50-docker-常规软件的安装">#</a> 5.0 docker 常规软件的安装</h3>
<h4 id="501步骤"><a class="markdownIt-Anchor" href="#501步骤">#</a> 5.0.1. 步骤</h4>
<p>（1）. 搜索镜像</p>
<p>（2）. 拉取镜像</p>
<p>（3）. 查看镜像</p>
<p>（4）. 启动镜像</p>
<p>（5）. 停止容器</p>
<p>（6）. 移除容器</p>
<h4 id="502安装tomcat"><a class="markdownIt-Anchor" href="#502安装tomcat">#</a> 5.0.2. 安装 tomcat</h4>
<p>（1）.docker search tomcat</p>
<p>（2）.docker pull tomcat</p>
<p>（3）.docker images</p>
<p>（4）.docker run -itd -p 8080:8080 --name=t1  tomcat</p>
<p>（5）. 访问报 404 (1. 没有关闭防火墙，2. 进入 tomcat docker exec -it 容器 ID/bin/bash ，然后 rm -r webapps , 最后 mv webapps.dist webapps）</p>
<p>（6）.docker stop 容器 ID</p>
<p>（7）.docker rmi 镜像 ID</p>
<h4 id="503安装mysql"><a class="markdownIt-Anchor" href="#503安装mysql">#</a> 5.0.3. 安装 mysql</h4>
<p>（1）.docker search mysql</p>
<p>（2）.docker pull mysql:5…7</p>
<p>（3）.docker images</p>
<p>（4）. docker run -itd -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 --name=mysql1  mysql:5.7</p>
<p>（5）. docker exec -it 容器 ID /bin/bash</p>
<p>（6）.docker stop 容器 ID</p>
<p>（7）.docker rmi 镜像 ID</p>
<p>配置 utf8</p>
<p>（8）.docker run -d -p 3306:3306 --privileged=true -v  /cgcuse/mysql/log:/var/log/mysql -v /cgcuse/mysql/data:/var/lib/mysql -v     /cgcuse/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  --name=mysql mysql:5.7</p>
<p>（9）.cd/cgcuse/mysql/conf  然后 vim my.conf</p>
<p>最后 ：</p>
<p>[client]<br>
default_character_set=utf8<br>
[mysqld]<br>
collation_server=utf8_general_ci<br>
character_set_server=utf8</p>
<h4 id="504安装redis"><a class="markdownIt-Anchor" href="#504安装redis">#</a> 5.0.4 安装 redis</h4>
<p>（1）.docker search redis</p>
<p>（2）.docker pull mysql:5…7</p>
<p>（3）.docker images</p>
<p>（4）.docker run -itd -p 6379:6379 --name=redistest redis:6.0.8</p>
<p>（5）.docker exec -it 容器 ID /bin/bash</p>
<p>（6）.redis-cli</p>
<p>（7）.docker stop 容器 ID</p>
<p>（8）.docker rmi 镜像 ID</p>
<h3 id="60-mysql主从复制"><a class="markdownIt-Anchor" href="#60-mysql主从复制">#</a> 6.0 mysql 主从复制</h3>
<h4 id="601新建主服务器容器实例3307"><a class="markdownIt-Anchor" href="#601新建主服务器容器实例3307">#</a> 6.0.1. 新建主服务器容器实例 3307</h4>
<pre><code>docker run -d -p 3307:3306 --privileged=true -v  /cgcuse/mysql-master/log:/var/log/mysql -v /cgcuse/mysql-master/data:/var/lib/mysql -v  /cgcuse/mysql-master/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root  --name=mysql-master mysql:5.7
</code></pre>
<h4 id="602进入-cgcusemysql-masterconf-目录下新建mycnf-vim-mycnf"><a class="markdownIt-Anchor" href="#602进入-cgcusemysql-masterconf-目录下新建mycnf-vim-mycnf">#</a> 6.0.2. 进入 /cgcuse/mysql-master/conf 目录下新建 my.cnf       vim my.cnf</h4>
<pre><code>[mysqld]
## 设置server_id，同一局域网中需要唯一
server_id=101 
## 指定不需要同步的数据库名称
binlog-ignore-db=mysql  
## 开启二进制日志功能
log-bin=mall-mysql-bin  
## 设置二进制日志使用内存大小（事务）
binlog_cache_size=1M  
## 设置使用的二进制日志格式（mixed,statement,row）
binlog_format=mixed  
## 二进制日志过期清理时间。默认值为0，表示不自动清理。
expire_logs_days=7  
## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062
</code></pre>
<h4 id="603修改完配置后重启master实例"><a class="markdownIt-Anchor" href="#603修改完配置后重启master实例">#</a> 6.0.3. 修改完配置后重启 master 实例</h4>
<p>docker restart mysql-master</p>
<h4 id="604进入容器"><a class="markdownIt-Anchor" href="#604进入容器">#</a> 6.0.4. 进入容器</h4>
<p>docker exec -it 容器 ID /bin/bash</p>
<p>mysql -uroot -proot</p>
<h4 id="605master容器实例内创建数据同步用户"><a class="markdownIt-Anchor" href="#605master容器实例内创建数据同步用户">#</a> 6.0.5.master 容器实例内创建数据同步用户</h4>
<p>create user ‘slave’@’%’ identified by ‘123456’;</p>
<p>grant replication slave ,replication client on <em>.</em> to ‘slave’@’%’；</p>
<h4 id="606新建从服务器容器实例3308"><a class="markdownIt-Anchor" href="#606新建从服务器容器实例3308">#</a> 6.0.6. 新建从服务器容器实例 3308</h4>
<pre><code>docker run -d -p 3308:3306 --privileged=true -v  /cgcuse/mysql-slave/log:/var/log/mysql -v /cgcuse/mysql-slave/data:/var/lib/mysql -v  /cgcuse/mysql-slave/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root  --name=mysql-slave mysql:5.7
</code></pre>
<h4 id="607进入-cgcusemysql-slaveconf-目录下新建mycnf-vim-mycnf"><a class="markdownIt-Anchor" href="#607进入-cgcusemysql-slaveconf-目录下新建mycnf-vim-mycnf">#</a> 6.0.7. 进入 /cgcuse/mysql-slave/conf 目录下新建 my.cnf       vim my.cnf</h4>
<pre><code>[mysqld]
## 设置server_id，同一局域网中需要唯一
server_id=102
## 指定不需要同步的数据库名称
binlog-ignore-db=mysql  
## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用
log-bin=mall-mysql-slave1-bin  
## 设置二进制日志使用内存大小（事务）
binlog_cache_size=1M  
## 设置使用的二进制日志格式（mixed,statement,row）
binlog_format=mixed  
## 二进制日志过期清理时间。默认值为0，表示不自动清理。
expire_logs_days=7  
## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062  
## relay_log配置中继日志
relay_log=mall-mysql-relay-bin  
## log_slave_updates表示slave将复制事件写进自己的二进制日志
log_slave_updates=1  
## slave设置为只读（具有super权限的用户除外）
read_only=1
</code></pre>
<h4 id="608修改完配置后重启slave实例"><a class="markdownIt-Anchor" href="#608修改完配置后重启slave实例">#</a> 6.0.8. 修改完配置后重启 slave 实例</h4>
<p>docker restart mysql-slave</p>
<h4 id="609在主数据库中查看主从同步状态"><a class="markdownIt-Anchor" href="#609在主数据库中查看主从同步状态">#</a> 6.0.9. 在主数据库中查看主从同步状态</h4>
<p>show master status;</p>
<h4 id="6010进入mysql-slave容器"><a class="markdownIt-Anchor" href="#6010进入mysql-slave容器">#</a> 6.0.10. 进入 mysql-slave 容器</h4>
<p>docker exec -it 容器 ID  /bin/bash</p>
<h4 id="6011在数据库中配置主从复制"><a class="markdownIt-Anchor" href="#6011在数据库中配置主从复制">#</a> 6.0.11. 在数据库中配置主从复制</h4>
<p>change master to master_host=‘宿主机 ip’, master_user=‘slave’, master_password=‘123456’, master_port=3307, master_log_file=‘mall-mysql-bin.000001’, master_log_pos=617, master_connect_retry=30;</p>
<p>master_host：主数据库的 IP 地址；</p>
<p>master_port：主数据库的运行端口；</p>
<p>master_user：在主数据库创建的用于同步数据的用户账号；</p>
<p>master_password：在主数据库创建的用于同步数据的用户密码；</p>
<p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取 File 参数；</p>
<p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取 Position 参数；</p>
<p>master_connect_retry：连接失败重试的时间间隔，单位为秒。</p>
<h4 id="6012在从数据库中查看主从同步状态"><a class="markdownIt-Anchor" href="#6012在从数据库中查看主从同步状态">#</a> 6.0.12. 在从数据库中查看主从同步状态</h4>
<p>show slave status \G;</p>
<h4 id="6013在从数据库中开启主从同步"><a class="markdownIt-Anchor" href="#6013在从数据库中开启主从同步">#</a> 6.0.13. 在从数据库中开启主从同步</h4>
<p>start slave;</p>
<h4 id="6014查看从数据库状态发现已经同步"><a class="markdownIt-Anchor" href="#6014查看从数据库状态发现已经同步">#</a> 6.0.14. 查看从数据库状态发现已经同步</h4>
<p>show slave status \G;</p>
<h4 id="6015主从复制测试"><a class="markdownIt-Anchor" href="#6015主从复制测试">#</a> 6.0.15. 主从复制测试</h4>
<p>navicate 连接主库添加，从库查看或者命令添加；</p>
<h3 id="70分布式存储"><a class="markdownIt-Anchor" href="#70分布式存储">#</a> 7.0. 分布式存储</h3>
<h4 id="701哈希取余算法"><a class="markdownIt-Anchor" href="#701哈希取余算法">#</a> 7.0.1. 哈希取余算法</h4>
<p>2 亿条记录就是 2 亿个 k，v，我们单机不行必须要分布式多机，假设有 3 台机器构成一个集群，用户每次读写操作都是根据公式；</p>
<p>hash (key)% N 个机器台数，计算出哈希值，用来决定数据映射到哪一个结点上；</p>
<p>优点：简单粗暴，直接有效，只需要预估好数据规划好节点，列如 3 台，8 台，10 台，就能保证一段时间的数据支撑，使用 Hash 算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并且维护这些请求信息）, 起到负载均衡 + 分而治之的作用；</p>
<p>缺点：原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash (key)/3 会变成 Hash (key) /?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。</p>
<p>某个 redis 机器宕机了，由于台数数量变化，会导致 hash 取余全部数据重新洗牌。</p>
<h4 id="702一致性哈希算法"><a class="markdownIt-Anchor" href="#702一致性哈希算法">#</a> 7.0.2. 一致性哈希算法</h4>
<p>1. 目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不 OK 了。</p>
<p>步骤:</p>
<p>(1). 算法构建一致性哈希环：</p>
<p>​     一致性哈希算法必然有个 hash 函数并按照算法产生 hash 值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个 hash 空间 [0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连 (0 = 2^32), 这样让它逻辑上形成了一个环形空间。</p>
<p>​       它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性 Hash 算法是对 2<sup>32 取模，简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数 H 的值空间为 0-2</sup>32-1（即哈希值是一个 32 位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、…… 直到 2<sup>32-1，也就是说 0 点左侧的第一个点代表 2</sup>32-1， 0 和 2<sup>32-1 在零点中方向重合，我们把这个由 2</sup>32 个点组成的圆环称为 Hash 环。</p>
<p>(2). 服务器 IP 节点映射</p>
<p>​       将集群中各个 IP 节点映射到环上的某一个位置。  将各个服务器使用 Hash 进行一个哈希，具体可以选择服务器的 IP 或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如 4 个节点 NodeA、B、C、D，经过 IP 地址的哈希函数计算 (hash (ip))，使用 IP 地址哈希后在环空间的位置如下：</p>
<p>(3).key 落到服务器的落建规则</p>
<p>​       当我们需要存储一个 kv 键值对时，首先计算 key 的 hash 值，hash (key)，将这个 key 使用相同的函数 Hash 计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针 “行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>
<p>​       如我们有 Object A、Object B、Object C、Object D 四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性 Hash 算法，数据 A 会被定为到 Node A 上，B 被定为到 Node B 上，C 被定为到 Node C 上，D 被定为到 Node D 上。</p>
<p>优点：</p>
<p><strong>容错性</strong></p>
<p>假设 Node C 宕机，可以看到此时对象 A、B、D 不会受到影响，只有 C 对象被重定位到 Node D。一般的，在一致性 Hash 算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是 C 挂了，受到影响的只是 B、C 之间的数据，并且这些数据会转移到 D 进行存储。</p>
<p><strong>扩展性</strong></p>
<p>数据量增加了，需要增加一台节点 NodeX，X 的位置在 A 和 B 之间，那收到影响的也就是 A 到 X 之间的数据，重新把 A 到 X 的数据录入到 X 上即可，</p>
<p>不会导致 hash 取余全部数据重新洗牌。</p>
<p>缺点：</p>
<p>Hash 环的数据倾斜问题</p>
<p>一致性 Hash 算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，</p>
<p>为了在节点数目发生改变时尽可能少的迁移数据</p>
<p>将所有的存储节点排列在收尾相接的 Hash 环上，每个 key 在计算 Hash 后会顺时针找到临近的存储节点存放。</p>
<p>而当有节点加入或退出时仅影响该节点在 Hash 环上顺时针相邻的后续节点。</p>
<p>优点</p>
<p>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p>
<p>缺点</p>
<p>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p>
<h4 id="703哈希槽算法"><a class="markdownIt-Anchor" href="#703哈希槽算法">#</a> 7.0.3. 哈希槽算法</h4>
<p>1. 是什么？</p>
<p>哈希槽实质就是一个数组，数组 [0,2^14 -1] 形成 hash slot 空间。</p>
<p>2. 可以干什么？</p>
<p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</p>
<p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p>
<p>哈希解决的是映射问题，使用 key 的哈希值来计算所在的槽，便于数据分配。</p>
<p>3. 多少个 hash 槽？</p>
<p>一个集群只能有 16384 个槽，编号 0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对 key 求哈希值，然后对 16384 取余，余数是几 key 就落入对应的槽里。slot = CRC16 (key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>
<p>4. 计算</p>
<p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key 之 A 、B 在 Node2， key 之 C 落在 Node3 上</p>
<h3 id="80-redis-3主3从集群"><a class="markdownIt-Anchor" href="#80-redis-3主3从集群">#</a> 8.0 Redis 3 主 3 从集群</h3>
<h4 id="801-3主3从redis集群配置"><a class="markdownIt-Anchor" href="#801-3主3从redis集群配置">#</a> 8.0.1 3 主 3 从 redis 集群配置</h4>
<p>1. 关闭防火墙 + 启动 docker 后台服务、</p>
<p>（1）. systemctl start docker</p>
<p>2. 新建 6 个 docker 容器实例</p>
<pre><code>docker run -d --name redis-node-1 --net host --privileged=true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381

docker run -d --name redis-node-2 --net host --privileged=true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382

docker run -d --name redis-node-3 --net host --privileged=true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383

docker run -d --name redis-node-4 --net host --privileged=true -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384

docker run -d --name redis-node-5 --net host --privileged=true -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385

docker run -d --name redis-node-6 --net host --privileged=true -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386
</code></pre>
<p><img data-src="/redis.jpg" alt=""></p>
<p>3. 进入容器 redis-node-1 并为 6 台机器构建集群关系</p>
<p>（1）. 进入容器 docker exec -it 容器 ID  /bin/bash</p>
<p>（2）. 构建主从关系</p>
<pre><code>redis-cli --cluster create 1.15.175.46:6381 1.15.175.46:6382 1.15.175.46:6383 1.15.175.46:6384 1.15.175.46:6385 1.15.175.46:6386 --cluster-replicas 1
</code></pre>
<p>出现以下结果就成功了。</p>
<p><img data-src="/redis-hash.jpg" alt=""></p>
<p>4. 查看集群状态</p>
<p>（1）.redis-cli -p 6381</p>
<p>（2）.cluster info</p>
<p>（3）.cluster nodes</p>
<h4 id="802-3从容错切换迁移案例"><a class="markdownIt-Anchor" href="#802-3从容错切换迁移案例">#</a> 8.0.2 3 从容错切换迁移案例</h4>
<p>1. 数据读写存储</p>
<p>（1）. 启动 6 机构成的集群并且使用 exec 进入</p>
<p>（2）. 对 6381 新增两个 key</p>
<p>（3）. 防止路由失效加参数 - c 并新增两个 key</p>
<p>redis-cli -p 6381 -c</p>
<p>（4）. 查看集群信息</p>
<p>redis-cli --cluster check 1.15.175.46:6381</p>
<p>2. 容错切换迁移</p>
<p>（1）. 主 6381 和从机切换，先停止主机 6381</p>
<p>1.6381 主机停了，对应的真实从机上位</p>
<p>2.6381 作为 1 号主机分配的从机以实际情况为准，具体是几号机器就是几号</p>
<p>docker stop redis-node-1</p>
<p>（2）. 再次查看集群信息</p>
<p>docker exec -it redis-node-2 bash</p>
<p>redis-cli -p 6382 -c</p>
<p>cluster nodes</p>
<p>（3）. 先还原之前的 3 主 3 从</p>
<p>docker start redis-node-1</p>
<p>docker stop redis-node-5</p>
<p>docker start redis-node-5</p>
<p>（4）. 查看集群状态</p>
<p>redis-cli --cluster check 1.15.175.46:6381</p>
<h4 id="803-3从扩容案例"><a class="markdownIt-Anchor" href="#803-3从扩容案例">#</a> 8.0.3 3 从扩容案例</h4>
<p>1. 新建 6387，6388 两个节点 + 新建后启动 + 查看是否 8 节点</p>
<table>
<thead>
<tr>
<th>docker run -d --name redis-node-7 --net host --privileged=true -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker run -d --name redis-node-8 --net host --privileged=true -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</td>
</tr>
<tr>
<td>docker ps</td>
</tr>
</tbody>
</table>
<p>2. 进入 6387 容器实例内部</p>
<p>docker exec -it redis-node-7 bash</p>
<p>3. 将新增的 6387 节点（空槽号）作为节点加入原集群</p>
<p>redis-cli --cluster add-node 1.15.175.46:6387 1.15.175.46:6381</p>
<p>4. 检查集群情况第一次</p>
<p>redis-cli --cluster check 真实 ip 地址：6381</p>
<p>5. 重新分派槽号</p>
<p>命令:redis-cli --cluster <strong>reshard</strong> IP 地址：端口号</p>
<p>redis-cli --cluster reshard  1.15.175.46:6381</p>
<p>6. 检查集群情况第二次</p>
<p>redis-cli --cluster check 真实 ip 地址：6381</p>
<p>7. 为主节点 6387 分配从节点 6388</p>
<p>命令：redis-cli --cluster add-node ip: 新 slave 端口 ip: 新 master 端口 --cluster-slave --cluster-master-id 新主机节点 ID</p>
<p>redis-cli --cluster add-node  1.15.175.46:6388  1.15.175.46:6387 --cluster-slave --cluster-master-id e4781f644d4a4e4d4b4d107157b9ba8144631451------- 这个是 6387 的编号，按照自己实际情况</p>
<p>8. 检查集群情况第三次</p>
<p>redis-cli --cluster check 真实 ip 地址：6388</p>
<h4 id="804-3从缩容案例"><a class="markdownIt-Anchor" href="#804-3从缩容案例">#</a> 8.0.4 3 从缩容案例</h4>
<p>1. 下线 6387，6388 两个节点</p>
<p>2. 检查集群情况 1 获得 6388 的节点 ID</p>
<p>redis-cli --cluster check 真实 ip 地址：6388</p>
<p>3. 将 6388 删除，从集群中将 4 号从节点 6388 删除</p>
<p>命令：redis-cli --cluster del-node ip: 从机端口 从机 6388 节点 ID</p>
<p>redis-cli --cluster del-node 1.15.175.46:6388 5d149074b7e57b802287d1797a874ed7a1a284a8</p>
<p>4. 将 6387 的槽号清空重新分配本例将清出来的槽号都给 6381</p>
<p>redis-cli --cluster reshard 1.15.175.46:6381</p>
<p>5. 检查集群情况第二次</p>
<p>redis-cli --cluster check 真实 ip 地址：6381</p>
<p>6. 将 6387 删除</p>
<p>redis-cli --cluster del-node 1.15.175.46:6387 5d149074b7e57b802287d1797a874ed7a1a284a8</p>
<p>7. 检查集群情况第三次</p>
<p>redis-cli --cluster check 真实 ip 地址：6381</p>
<h3 id="90-dockerfile"><a class="markdownIt-Anchor" href="#90-dockerfile">#</a> 9.0 DockerFile</h3>
<h4 id="901dockerfile构建过程解析"><a class="markdownIt-Anchor" href="#901dockerfile构建过程解析">#</a> 9.0.1dockerfile 构建过程解析</h4>
<p>1.Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>
<p>2. 构建过程</p>
<p>（1）. 编写 Dockerfile 文件</p>
<p>（2）.docker build 命令构建镜像</p>
<p>（3）.docker run 运行镜像容器</p>
<p>3.Dockerfile 内容基础知识</p>
<p>（1）. 每条保留字指令都必须为大写字母且后面要跟随至少一个参数</p>
<p>（2）. 指令按照从上到下，顺序执行</p>
<p>（3）.# 表示注释</p>
<p>（4）. 每条指令都会创建一个新的镜像层并对镜像进行提交</p>
<p>4.Docker 执行 Dockerfile 的大致流程</p>
<p>（1）.docker 从基础镜像运行一个容器</p>
<p>（2）. 执行一条指令并对容器做出修改</p>
<p>（3）. 执行类似 docker commit 的操作提交一个新的镜像层</p>
<p>（4）.docker 再基于刚提交的镜像运行一个新的容器</p>
<p>（5）. 执行 dockerfile 中的下一条指令直到所有指令都执行完成</p>
<h4 id="902-dockerfile常用保留字指令"><a class="markdownIt-Anchor" href="#902-dockerfile常用保留字指令">#</a> 9.0.2 DockerFile 常用保留字指令</h4>
<p><strong>FROM</strong> : 基础镜像当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是 from</p>
<p><strong>MAINTAINER</strong> : 镜像维护者的姓名和邮箱地址</p>
<p><strong>RUN</strong> ：</p>
<p>1. 容器构建的时候需要运行的命令</p>
<p>2. 两种格式：1.shell 格式，exec 格式</p>
<p>3.RUN 是在 docker build 时运行</p>
<p><strong>EXPOSE</strong>: 当前容器对外暴露出的端口</p>
<p><strong>WORKDIR</strong> : 指定在创建容器后，终端默认登录的进来的工作目录，一个落脚点</p>
<p><strong>USER</strong> : 指定该镜像以什么样的用户去执行，如果都不指定，默认是 root</p>
<p><strong>ENV</strong> : 用来在构建镜像过程中设置环境变量</p>
<p>ENV key value</p>
<p><strong>ADD</strong> : 将宿主机目录下的文件拷贝进镜像且会自动处理 URL 和解压 tar 压缩包</p>
<p><strong>COPY</strong> : 类似 ADD ，拷贝文件和目录到镜像中。</p>
<p>将从构建上下文目录中 &lt;源路径&gt; 的文件 / 目录复制到新的一层的镜像内的 &lt; 目标路径 &gt; 位置</p>
<p>（1）.COPY src  dest</p>
<p>（2）.COPY[“src”,“dest”]</p>
<p>（3）.&lt;src 源路径&gt;: 源文件或者源目录</p>
<p>（4）.&lt;dest 目标路径&gt;: 容器内的指定路径，该路径不用事先创建好，如果路径不存在，会自动创建</p>
<p><strong>VOLUME</strong>: 容器数据卷，用于数据保存和持久化工作</p>
<p><strong>CMD</strong>: 指定容器启动后要干的事情（指令跟 RUN 相似）可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p>
<p>1.RUN 是在 docker build 时运行</p>
<p>2.CMD 是在 docker run 时运行</p>
<p><strong>ENTRYPOINT</strong>: 指定一个容器启动时要运行的命令，类似 CMD 但是不会被 docker run 之后的参数替换。</p>
<h4 id="903案例"><a class="markdownIt-Anchor" href="#903案例">#</a> 9.0.3 案例</h4>
<p>自定义镜像 mycentosjava8（具备 jdk8，ifconfig，vim）</p>
<p>下载 jdk 文件到 myfile 下</p>
<p>vim Dockerfile</p>
<pre><code>FROM centos
MAINTAINER haha&lt;haha@136.com&gt;
 
ENV MYPATH /usr/local
WORKDIR $MYPATH
 
#安装vim编辑器
RUN yum -y install vim
#安装ifconfig命令查看网络IP
RUN yum -y install net-tools
#安装java8及lib库
RUN yum -y install glibc.i686
RUN mkdir /usr/local/java
#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置
ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/
#配置java环境变量
ENV JAVA_HOME /usr/local/java/jdk1.8.0_171
ENV JRE_HOME $JAVA_HOME/jre
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH
ENV PATH $JAVA_HOME/bin:$PATH
 
EXPOSE 80
 
CMD echo $MYPATH
CMD echo &quot;success--------------ok&quot;
CMD /bin/bash
</code></pre>
<p>构建</p>
<p>docker build -t 新镜像名字:tag .</p>
<p>docker image prune 删除虚悬镜像</p>
<h4 id="904-微服务实战"><a class="markdownIt-Anchor" href="#904-微服务实战">#</a> 9.0.4 微服务实战</h4>
<p>1. 新建一个 springboot 微服务项目</p>
<p>2. 搞定微服务 jar 包</p>
<p>3.jar 包和 Dockerfile 放在同一个路径下</p>
<pre><code># 基础镜像使用java

FROM java:8

# 作者

MAINTAINER zzyy

# VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp

VOLUME /tmp

# 将jar包添加到容器中并更名为zzyy_docker.jar

ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar

# 运行jar包

RUN bash -c 'touch /zzyy_docker.jar'

ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]

#暴露6001端口作为微服务

EXPOSE 6001
</code></pre>
<p>4.docker build -t cgc_docker:1.6</p>
<p>5. 运行容器</p>
<p>docker run -itd  -p 6001:6001 容器 ID</p>
<p>6. 测试</p>
<h3 id="100-docker网络"><a class="markdownIt-Anchor" href="#100-docker网络">#</a> 10.0 Docker 网络</h3>
<h4 id="1001常用命令"><a class="markdownIt-Anchor" href="#1001常用命令">#</a> 10.0.1 常用命令</h4>
<p>1. 查看 docker 网络模式命令</p>
<p>docker network ls</p>
<p>2. 查看所有命令</p>
<p>docker network --help</p>
<p>3. 查看网络源数据</p>
<p>docker network inspect xxx 网络名字</p>
<p>4. 删除网络</p>
<p>docker network rm xxx 网络名字</p>
<p>5. 创建网络</p>
<p>docker network create 网络名字</p>
<h4 id="1002-作用"><a class="markdownIt-Anchor" href="#1002-作用">#</a> 10.0.2 作用</h4>
<p>1. 容器的互联和通信以及端口映射</p>
<p>2. 容器 IP 变动的时候可以通过服务名直接网络通信而不受到影像</p>
<h4 id="1003-网络模式"><a class="markdownIt-Anchor" href="#1003-网络模式">#</a> 10.0.3 网络模式</h4>
<p>1.bridge 模式：使用–network bridge 指定，默认使用 docker0</p>
<p>2.host 模式：使用–network host 指定</p>
<p>3.none 模式：使用–network none 指定</p>
<p>4.container 模式：使用–network container:NAME 或者容器 ID 指定</p>
<p>docker 容器内部 ip 时有可能会发生改变的</p>
<h5 id="10031-bridge"><a class="markdownIt-Anchor" href="#10031-bridge">#</a> 10.0.3.1 bridge</h5>
<p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为 docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</p>
<p># 查看 bridge 网络的详细信息，并通过 grep 获取名称项</p>
<p>docker network inspect bridge | grep name</p>
<p>1 Docker 使用 Linux 桥接，在宿主机虚拟一个 Docker 容器网桥 (docker0)，Docker 启动一个容器时会根据 Docker 网桥的网段分配给容器一个 IP 地址，称为 Container-IP，同时 Docker 网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 直接通信。</p>
<p>2 docker run 的时候，没有指定 network 的话默认使用的网桥模式就是 bridge，使用的就是 docker0。在宿主机 ifconfig, 就可以看到 docker0 和自己 create 的 network (后面讲) eth0，eth1，eth2…… 代表网卡一，网卡二，网卡三……，lo 代表 127.0.0.1，即 localhost，inet addr 用来表示网卡的 IP 地址</p>
<p>3 网桥 docker0 创建一对对等虚拟设备接口一个叫 veth，另一个叫 eth0，成对匹配。</p>
<p>3.1 整个宿主机的网桥模式都是 docker0，类似一个交换机有一堆接口，每个接口叫 veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫 veth pair）；</p>
<p>3.2 每个容器实例内部也有一块网卡，每个接口叫 eth0；</p>
<p>3.3 docker0 上面的每个 veth 匹配某个容器实例内部的 eth0，两两配对，一一匹配。</p>
<p>通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下，会从这个网关下各自拿到分配的 ip，此时两个容器的网络是互通的。</p>
<h5 id="10032-host"><a class="markdownIt-Anchor" href="#10032-host">#</a> 10.0.3.2 host</h5>
<p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行 NAT 转换。</p>
<p>容器将不会获得一个独立的 Network Namespace， 而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的 IP 和端口。</p>
<p>docker run -d  -p 8083:8083 --network host  --name …</p>
<h5 id="10033-none"><a class="markdownIt-Anchor" href="#10033-none">#</a> 10.0.3.3 none</h5>
<p>禁用网络功能只有 lo 标识</p>
<p>docker run -d  -p 8083:8083 --network none --name …</p>
<h5 id="10034-container"><a class="markdownIt-Anchor" href="#10034-container">#</a> 10.0.3.4 container</h5>
<p>container ⽹络模式</p>
<p>新建的容器和已经存在的一个容器共享一个网络 ip 配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p>
<p>docker run -it --network container:alpine1 --name …</p>
<h4 id="1011-docker-平台架构图解"><a class="markdownIt-Anchor" href="#1011-docker-平台架构图解">#</a> 10.1.1 docker 平台架构图解</h4>
<h5 id="10111整体说明"><a class="markdownIt-Anchor" href="#10111整体说明">#</a> 10.1.1.1. 整体说明</h5>
<p>从其架构和运行流程来看，Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。</p>
<p>Docker 运行的基本流程为：</p>
<p>1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p>
<p>2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p>
<p>3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p>
<p>4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver 将下载镜像以 Graph 的形式存储。</p>
<p>5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p>
<p>6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</p>
<p>7 Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作。</p>
<h5 id="10112整体架构"><a class="markdownIt-Anchor" href="#10112整体架构">#</a> 10.1.1.2. 整体架构</h5>
<p><img data-src="/jiagou.png" alt=""></p>
<p>​</p>
<h3 id="110-docker-compose-容器编排"><a class="markdownIt-Anchor" href="#110-docker-compose-容器编排">#</a> 11.0 Docker-compose 容器编排</h3>
<h4 id="1101-是什么"><a class="markdownIt-Anchor" href="#1101-是什么">#</a> 11.0.1 是什么？</h4>
<p>Docker-Compose 是 Docker 官方的开源项目，负责实现对容器集群的快速编排</p>
<h4 id="1102-能干什么"><a class="markdownIt-Anchor" href="#1102-能干什么">#</a> 11.0.2 能干什么？</h4>
<p>docker 建议我们每一个容器中只运行一个服务，因为 docker 容器本身占用资源极少，所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p>
<p>如果我需要同时部署好多个服务，难道要每个服务单独写 Dockerfile 然后在构建镜像，构建容器，这样累都累死了，所以 docker 官方给我们提供了 docker-compose 多服务部署的工具</p>
<p>例如要实现一个 Web 微服务项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库 mysql 服务容器，redis 服务器，注册中心 eureka，甚至还包括负载均衡容器等等。。。。。。</p>
<p>Compose 允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p>
<h4 id="1103-去哪里下载"><a class="markdownIt-Anchor" href="#1103-去哪里下载">#</a> 11.0.3 去哪里下载？</h4>
<p>下载：</p>
<p>1.curl -L “<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9jb21wb3NlL3JlbGVhc2VzL2Rvd25sb2FkLzEuMjkuMi9kb2NrZXItY29tcG9zZS0=">https://github.com/docker/compose/releases/download/1.29.2/docker-compose-</span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>−</mo><mi>s</mi><mo stretchy="false">)</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">(uname -s)-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mord">−</span></span></span></span>(uname -m)” -o /usr/local/bin/docker-compose</p>
<p>2.chmod +x /usr/local/bin/docker-compose</p>
<p>3.docker-compose --version</p>
<p>卸载：</p>
<p>sudo rm /usr/local/bin/docker-compose</p>
<h4 id="1104-compose核心概念"><a class="markdownIt-Anchor" href="#1104-compose核心概念">#</a> 11.0.4 Compose 核心概念</h4>
<p>1. 一文件 docker-compose.yml</p>
<p>2. 两要素</p>
<p>（1）. 服务：一个个应用容器实例，比如订单微服务，库存微服务，mysql 容器。</p>
<p>（2）. 工程：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p>
<h4 id="1105-compose常用命令"><a class="markdownIt-Anchor" href="#1105-compose常用命令">#</a> 11.0.5 Compose 常用命令</h4>
<p><strong>Compose**** 常用命令</strong></p>
<p>docker-compose -h              # 查看帮助</p>
<p>docker-compose up              # 启动所有 docker-compose 服务</p>
<p>docker-compose up -d             # 启动所有 docker-compose 服务并后台运行</p>
<p>docker-compose down             # 停止并删除容器、网络、卷、镜像。</p>
<p>docker-compose exec  yml 里面的服务 id         # 进入容器实例内部 docker-compose exec docker-compose.yml 文件中写的服务 id /bin/bash</p>
<p>docker-compose ps            # 展示当前 docker-compose 编排过的运行的所有容器</p>
<p>docker-compose top           # 展示当前 docker-compose 编排过的容器进程</p>
<p>docker-compose logs  yml 里面的服务 id   # 查看容器输出日志</p>
<p>docker-compose config   # 检查配置</p>
<p>docker-compose config -q # 检查配置，有问题才有输出</p>
<p>docker-compose restart  # 重启服务</p>
<p>docker-compose start   # 启动服务</p>
<p>docker-compose stop    # 停止服务</p>
<h4 id="1106-compose使用的三个步骤"><a class="markdownIt-Anchor" href="#1106-compose使用的三个步骤">#</a> 11.0.6 Compose 使用的三个步骤</h4>
<p>1. 编写 Dockerfile 定义各个微服务应用并构建出对应的镜像文件</p>
<p>2. 使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务</p>
<p>3. 最后执行 docker-compose up 命令并启动运行整个应用程序，完成一键部署上线</p>
<h4 id="1107-compose编排微服务"><a class="markdownIt-Anchor" href="#1107-compose编排微服务">#</a> 11.0.7 Compose 编排微服务</h4>
<p>1.package 把项目打包，放在与 docker-compose.yml 和 Dockerfile 同个目录下</p>
<p>2. 编写 docker-compose.yml 文件</p>
<pre><code>version: &quot;3&quot;

 

services:

  microService:

    image: zzyy_docker:1.6

    container_name: ms01

    ports:

      - &quot;6001:6001&quot;

    volumes:

      - /app/microService:/data

    networks: 

      - atguigu_net 

    depends_on: 

      - redis

      - mysql

 

  redis:

    image: redis:6.0.8

    ports:

      - &quot;6379:6379&quot;

    volumes:

      - /app/redis/redis.conf:/etc/redis/redis.conf

      - /app/redis/data:/data

    networks: 

      - atguigu_net

    command: redis-server /etc/redis/redis.conf

 

  mysql:

    image: mysql:5.7

    environment:

      MYSQL_ROOT_PASSWORD: '123456'

      MYSQL_ALLOW_EMPTY_PASSWORD: 'no'

      MYSQL_DATABASE: 'db2021'

      MYSQL_USER: 'zzyy'

      MYSQL_PASSWORD: 'zzyy123'

    ports:

       - &quot;3306:3306&quot;

    volumes:

       - /app/mysql/db:/var/lib/mysql

       - /app/mysql/conf/my.cnf:/etc/my.cnf

       - /app/mysql/init:/docker-entrypoint-initdb.d

    networks:

      - atguigu_net

    command: --default-authentication-plugin=mysql_native_password #解决外部无法访问

 

networks: 

   atguigu_net: 
</code></pre>
<p>3. 编写 Dockerfile 文件</p>
<pre><code># 基础镜像使用java

FROM java:8

# 作者

MAINTAINER zzyy

# VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp

VOLUME /tmp

# 将jar包添加到容器中并更名为zzyy_docker.jar

ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar

# 运行jar包

RUN bash -c 'touch /zzyy_docker.jar'

ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]

#暴露6001端口作为微服务

EXPOSE 6001
</code></pre>
<ol start="4">
<li>docker build -t zzyy_docker:1.6 .</li>
<li>执行 docker-compose up 或者 docker-compose up -d</li>
<li>关闭 docker-compose stop</li>
</ol>
<h3 id="130-docker-轻量级可视化工具portainer"><a class="markdownIt-Anchor" href="#130-docker-轻量级可视化工具portainer">#</a> 13.0 Docker 轻量级可视化工具 Portainer</h3>
<p>1. 是什么？</p>
<p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理 Docker 环境，包括单机环境和集群环境。</p>
<p>2. 安装</p>
<p>（1）. 命令</p>
<p>docker run -d -p 8000:8000 -p 9000:9000 --name portainer   --restart=always   -v /var/run/docker.sock:/var/run/docker.sock   -v portainer_data:/data   portainer/portainer</p>
<p>（2）. 设置账号密码</p>
<p>（3）. 地址 ip:9000</p>
<h3 id="140-docker-容器监控之cadvisorinfluxdbgranfana"><a class="markdownIt-Anchor" href="#140-docker-容器监控之cadvisorinfluxdbgranfana">#</a> 14.0 Docker 容器监控之 CAdvisor+InfluxDB+Granfana</h3>
<p>1. 监控</p>
<p>docker stats</p>
<p>2.CAdvisor+InfluxDB+Granfana</p>
<p><img data-src="C:%5CUsers%5C%E6%9B%B9%E9%AB%98%E5%9F%8E%5CDesktop%5Cdockerimages%5CCAdvisor.png" alt=""></p>
<p><img data-src="C:%5CUsers%5C%E6%9B%B9%E9%AB%98%E5%9F%8E%5CDesktop%5Cdockerimages%5CInfluxDB.png" alt=""></p>
<p><img data-src="C:%5CUsers%5C%E6%9B%B9%E9%AB%98%E5%9F%8E%5CDesktop%5Cdockerimages%5CGranfana.png" alt=""></p>
<p>2. 创建 cig 文件夹，新建 docker-compose.yml</p>
<pre><code>version: '3.1'

 

volumes:

  grafana_data: &#123;&#125;

 

services:

 influxdb:

  image: tutum/influxdb:0.9

  restart: always

  environment:

    - PRE_CREATE_DB=cadvisor

  ports:

    - &quot;8083:8083&quot;

    - &quot;8086:8086&quot;

  volumes:

    - ./data/influxdb:/data

 

 cadvisor:

  image: google/cadvisor

  links:

    - influxdb:influxsrv

  command: -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086

  restart: always

  ports:

    - &quot;8080:8080&quot;

  volumes:

    - /:/rootfs:ro

    - /var/run:/var/run:rw

    - /sys:/sys:ro

    - /var/lib/docker/:/var/lib/docker:ro

 

 grafana:

  user: &quot;104&quot;

  image: grafana/grafana

  user: &quot;104&quot;

  restart: always

  links:

    - influxdb:influxsrv

  ports:

    - &quot;3000:3000&quot;

  volumes:

    - grafana_data:/var/lib/grafana

  environment:

    - HTTP_USER=admin

    - HTTP_PASS=admin

    - INFLUXDB_HOST=influxsrv

    - INFLUXDB_PORT=8086

    - INFLUXDB_NAME=cadvisor

    - INFLUXDB_USER=root

    - INFLUXDB_PASS=root
</code></pre>
<p>3.docker-compose up</p>
<ol start="4">
<li></li>
</ol>
<p>（1）. 浏览 cAdvisor 收集服务 <span class="exturl" data-url="aHR0cDovL2lwOjgwODA=">http://ip:8080</span></p>
<p>（2）. 浏览 influxdb 存储服务 <span class="exturl" data-url="aHR0cDovL2lwOjgwODM=">http://ip:8083</span></p>
<p>（3）. 浏览 grafana 展现服务  <span class="exturl" data-url="aHR0cDovL2lwOjMwMDA=">http://ip:3000</span></p>

      <div class="tags">
          <a href="/tags/Docker/" rel="tag"><i class="ic i-tag"></i> Docker</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2022-05-02 22:33:12" itemprop="dateModified" datetime="2022-05-02T22:33:12+08:00">2022-05-02</time>
  </span>
  <span id="computer-science/container/Docker/docker/" class="item leancloud_visitors" data-flag-title="docker笔记" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="//cdn.jsdelivr.net/gh/hahayixiao2/hahayixiao2.github.io@latest/images/wechatpay.png" alt="hahayixiao 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="//cdn.jsdelivr.net/gh/hahayixiao2/hahayixiao2.github.io@latest/images/alipay.png" alt="hahayixiao 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="//cdn.jsdelivr.net/gh/hahayixiao2/hahayixiao2.github.io@latest/images/paypal.png" alt="hahayixiao 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>hahayixiao <i class="ic i-at"><em>@</em></i>一个小萌新的进阶之路
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://hahayixiao2.github.io/computer-science/container/Docker/docker/" title="docker笔记">https://hahayixiao2.github.io/computer-science/container/Docker/docker/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/computer-science/container/DockerCompose%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/dockercompose/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclip4jbpj20zk0m87cv.jpg" title="dockercompose笔记">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 容器</span>
  <h3>dockercompose笔记</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/computer-science/container/DockerDesktop%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/dockerdesktop/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclwrdwyaj20zk0m8are.jpg" title="dockercompose笔记">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> 容器</span>
  <h3>dockercompose笔记</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker"><span class="toc-number">1.</span> <span class="toc-text"> docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-docker-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.0 docker 安装步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#101-docker-%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A0%E9%80%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1.0.1 docker 配置阿里云加速</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text"> 2.0 docker 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#201-%E5%B8%AE%E5%8A%A9%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 2.0.1 帮助启动类命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#202-%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 2.0.2 镜像命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2021-%E6%98%BE%E7%A4%BA%E5%B7%B2%E6%9C%89%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text"> 2.0.2.1 显示已有镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2022-%E4%BB%8E%E4%BB%93%E5%BA%93%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text"> 2.0.2.2 从仓库查找镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2023-%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.2.3.</span> <span class="toc-text"> 2.0.2.3 下载镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2024-%E6%9F%A5%E7%9C%8Bdocker%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.2.2.4.</span> <span class="toc-text"> 2.0.2.4 查看 docker 资源占用情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2025-%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.2.5.</span> <span class="toc-text"> 2.0.2.5  删除镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2026-%E5%90%AF%E5%8A%A8%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.6.</span> <span class="toc-text"> 2.0.2.6 启动交互式容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2027-%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.7.</span> <span class="toc-text"> 2.0.2.7 查看容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2028-%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.8.</span> <span class="toc-text"> 2.0.2.8 退出容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2029-%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.9.</span> <span class="toc-text"> 2.0.2.9 启动容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20210-%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.10.</span> <span class="toc-text"> 2.0.2.10 停止容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20211-%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.11.</span> <span class="toc-text"> 2.0.2.11 重启容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20212-%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.12.</span> <span class="toc-text"> 2.0.2.12 强制停止容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20213-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.13.</span> <span class="toc-text"> 2.0.2.13 删除已停止的容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20214-%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-number">1.2.2.14.</span> <span class="toc-text"> 2.0.2.14 查看日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20215-%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.2.15.</span> <span class="toc-text"> 2.0.2.15 查看容器内运行的进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20216-%E9%87%8D%E6%96%B0%E8%BF%9B%E5%85%A5%E7%BB%88%E7%AB%AF"><span class="toc-number">1.2.2.16.</span> <span class="toc-text"> 2.0.2.16 重新进入终端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20217-%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.17.</span> <span class="toc-text"> 2.0.2.17 拷贝文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20218-%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.18.</span> <span class="toc-text"> 2.0.2.18 导入和导出容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-docker-%E9%95%9C%E5%83%8F"><span class="toc-number">1.3.</span> <span class="toc-text"> 3.0 docker 镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-docker-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.4.</span> <span class="toc-text"> 4.0 docker 容器数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-docker-%E5%B8%B8%E8%A7%84%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.5.</span> <span class="toc-text"> 5.0 docker 常规软件的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#501%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 5.0.1. 步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#502%E5%AE%89%E8%A3%85tomcat"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 5.0.2. 安装 tomcat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#503%E5%AE%89%E8%A3%85mysql"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 5.0.3. 安装 mysql</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#504%E5%AE%89%E8%A3%85redis"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 5.0.4 安装 redis</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text"> 6.0 mysql 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#601%E6%96%B0%E5%BB%BA%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B3307"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 6.0.1. 新建主服务器容器实例 3307</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#602%E8%BF%9B%E5%85%A5-cgcusemysql-masterconf-%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BAmycnf-vim-mycnf"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 6.0.2. 进入 &#x2F;cgcuse&#x2F;mysql-master&#x2F;conf 目录下新建 my.cnf       vim my.cnf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#603%E4%BF%AE%E6%94%B9%E5%AE%8C%E9%85%8D%E7%BD%AE%E5%90%8E%E9%87%8D%E5%90%AFmaster%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 6.0.3. 修改完配置后重启 master 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#604%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text"> 6.0.4. 进入容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#605master%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E5%86%85%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%94%A8%E6%88%B7"><span class="toc-number">1.6.5.</span> <span class="toc-text"> 6.0.5.master 容器实例内创建数据同步用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#606%E6%96%B0%E5%BB%BA%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B3308"><span class="toc-number">1.6.6.</span> <span class="toc-text"> 6.0.6. 新建从服务器容器实例 3308</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#607%E8%BF%9B%E5%85%A5-cgcusemysql-slaveconf-%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BAmycnf-vim-mycnf"><span class="toc-number">1.6.7.</span> <span class="toc-text"> 6.0.7. 进入 &#x2F;cgcuse&#x2F;mysql-slave&#x2F;conf 目录下新建 my.cnf       vim my.cnf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#608%E4%BF%AE%E6%94%B9%E5%AE%8C%E9%85%8D%E7%BD%AE%E5%90%8E%E9%87%8D%E5%90%AFslave%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.6.8.</span> <span class="toc-text"> 6.0.8. 修改完配置后重启 slave 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#609%E5%9C%A8%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81"><span class="toc-number">1.6.9.</span> <span class="toc-text"> 6.0.9. 在主数据库中查看主从同步状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6010%E8%BF%9B%E5%85%A5mysql-slave%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.10.</span> <span class="toc-text"> 6.0.10. 进入 mysql-slave 容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6011%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.6.11.</span> <span class="toc-text"> 6.0.11. 在数据库中配置主从复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6012%E5%9C%A8%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81"><span class="toc-number">1.6.12.</span> <span class="toc-text"> 6.0.12. 在从数据库中查看主从同步状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6013%E5%9C%A8%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%BC%80%E5%90%AF%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.6.13.</span> <span class="toc-text"> 6.0.13. 在从数据库中开启主从同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6014%E6%9F%A5%E7%9C%8B%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8A%B6%E6%80%81%E5%8F%91%E7%8E%B0%E5%B7%B2%E7%BB%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">1.6.14.</span> <span class="toc-text"> 6.0.14. 查看从数据库状态发现已经同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6015%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.6.15.</span> <span class="toc-text"> 6.0.15. 主从复制测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.7.</span> <span class="toc-text"> 7.0. 分布式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#701%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.1.</span> <span class="toc-text"> 7.0.1. 哈希取余算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#702%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.2.</span> <span class="toc-text"> 7.0.2. 一致性哈希算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#703%E5%93%88%E5%B8%8C%E6%A7%BD%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.3.</span> <span class="toc-text"> 7.0.3. 哈希槽算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-redis-3%E4%B8%BB3%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="toc-number">1.8.</span> <span class="toc-text"> 8.0 Redis 3 主 3 从集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#801-3%E4%B8%BB3%E4%BB%8Eredis%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">1.8.1.</span> <span class="toc-text"> 8.0.1 3 主 3 从 redis 集群配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#802-3%E4%BB%8E%E5%AE%B9%E9%94%99%E5%88%87%E6%8D%A2%E8%BF%81%E7%A7%BB%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text"> 8.0.2 3 从容错切换迁移案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#803-3%E4%BB%8E%E6%89%A9%E5%AE%B9%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.3.</span> <span class="toc-text"> 8.0.3 3 从扩容案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#804-3%E4%BB%8E%E7%BC%A9%E5%AE%B9%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.4.</span> <span class="toc-text"> 8.0.4 3 从缩容案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-dockerfile"><span class="toc-number">1.9.</span> <span class="toc-text"> 9.0 DockerFile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#901dockerfile%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">1.9.1.</span> <span class="toc-text"> 9.0.1dockerfile 构建过程解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#902-dockerfile%E5%B8%B8%E7%94%A8%E4%BF%9D%E7%95%99%E5%AD%97%E6%8C%87%E4%BB%A4"><span class="toc-number">1.9.2.</span> <span class="toc-text"> 9.0.2 DockerFile 常用保留字指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#903%E6%A1%88%E4%BE%8B"><span class="toc-number">1.9.3.</span> <span class="toc-text"> 9.0.3 案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#904-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98"><span class="toc-number">1.9.4.</span> <span class="toc-text"> 9.0.4 微服务实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100-docker%E7%BD%91%E7%BB%9C"><span class="toc-number">1.10.</span> <span class="toc-text"> 10.0 Docker 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1001%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.10.1.</span> <span class="toc-text"> 10.0.1 常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1002-%E4%BD%9C%E7%94%A8"><span class="toc-number">1.10.2.</span> <span class="toc-text"> 10.0.2 作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1003-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.10.3.</span> <span class="toc-text"> 10.0.3 网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10031-bridge"><span class="toc-number">1.10.3.1.</span> <span class="toc-text"> 10.0.3.1 bridge</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10032-host"><span class="toc-number">1.10.3.2.</span> <span class="toc-text"> 10.0.3.2 host</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10033-none"><span class="toc-number">1.10.3.3.</span> <span class="toc-text"> 10.0.3.3 none</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10034-container"><span class="toc-number">1.10.3.4.</span> <span class="toc-text"> 10.0.3.4 container</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1011-docker-%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.10.4.</span> <span class="toc-text"> 10.1.1 docker 平台架构图解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10111%E6%95%B4%E4%BD%93%E8%AF%B4%E6%98%8E"><span class="toc-number">1.10.4.1.</span> <span class="toc-text"> 10.1.1.1. 整体说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10112%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.10.4.2.</span> <span class="toc-text"> 10.1.1.2. 整体架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110-docker-compose-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92"><span class="toc-number">1.11.</span> <span class="toc-text"> 11.0 Docker-compose 容器编排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1101-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.11.1.</span> <span class="toc-text"> 11.0.1 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1102-%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88"><span class="toc-number">1.11.2.</span> <span class="toc-text"> 11.0.2 能干什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1103-%E5%8E%BB%E5%93%AA%E9%87%8C%E4%B8%8B%E8%BD%BD"><span class="toc-number">1.11.3.</span> <span class="toc-text"> 11.0.3 去哪里下载？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1104-compose%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.11.4.</span> <span class="toc-text"> 11.0.4 Compose 核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1105-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.5.</span> <span class="toc-text"> 11.0.5 Compose 常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1106-compose%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.11.6.</span> <span class="toc-text"> 11.0.6 Compose 使用的三个步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1107-compose%E7%BC%96%E6%8E%92%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.11.7.</span> <span class="toc-text"> 11.0.7 Compose 编排微服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#130-docker-%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7portainer"><span class="toc-number">1.12.</span> <span class="toc-text"> 13.0 Docker 轻量级可视化工具 Portainer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#140-docker-%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7%E4%B9%8Bcadvisorinfluxdbgranfana"><span class="toc-number">1.13.</span> <span class="toc-text"> 14.0 Docker 容器监控之 CAdvisor+InfluxDB+Granfana</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li class="active"><a href="/computer-science/container/Docker/docker/" rel="bookmark" title="docker笔记">docker笔记</a></li><li><a href="/computer-science/container/DockerCompose%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/dockercompose/" rel="bookmark" title="dockercompose笔记">dockercompose笔记</a></li><li><a href="/computer-science/container/DockerDesktop%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/dockerdesktop/" rel="bookmark" title="dockercompose笔记">dockercompose笔记</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="hahayixiao"
      data-src="//cdn.jsdelivr.net/gh/hahayixiao2/hahayixiao2.github.io@latest/images/avatar.png">
  <p class="name" itemprop="name">hahayixiao</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">10</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">4</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">5</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhaGF5aXhpYW8y" title="https:&#x2F;&#x2F;github.com&#x2F;hahayixiao2"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/computer-science/container/DockerCompose%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/dockercompose/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/computer-science/container/DockerDesktop%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/dockerdesktop/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机">计算机</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/" title="分类于 教程">教程</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/theme-shoka-doc/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a>
</div>

    <span><a href="/computer-science/note/theme-shoka-doc/display/" title="Step.3 界面显示">Step.3 界面显示</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机">计算机</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/" title="分类于 教程">教程</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/theme-shoka-doc/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a>
</div>

    <span><a href="/computer-science/note/theme-shoka-doc/config/" title="Step.2 基本配置">Step.2 基本配置</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/code-highlight/" title="Code Highlight Style test">Code Highlight Style test</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机">计算机</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/container/" title="分类于 容器">容器</a>
</div>

    <span><a href="/computer-science/container/DockerDesktop%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/dockerdesktop/" title="dockercompose笔记">dockercompose笔记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机">计算机</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/" title="分类于 教程">教程</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/theme-shoka-doc/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a>
</div>

    <span><a href="/computer-science/note/theme-shoka-doc/dependents/" title="Step.1 依赖插件">Step.1 依赖插件</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机">计算机</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/container/" title="分类于 容器">容器</a>
</div>

    <span><a href="/computer-science/container/DockerCompose%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/dockercompose/" title="dockercompose笔记">dockercompose笔记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机">计算机</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/" title="分类于 教程">教程</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/theme-shoka-doc/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a>
</div>

    <span><a href="/computer-science/note/theme-shoka-doc/" title="Hexo主题Shoka &amp; multi-markdown-it渲染器使用说明">Hexo主题Shoka & multi-markdown-it渲染器使用说明</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/markdown/" title="Markdown Style test">Markdown Style test</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机">计算机</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/container/" title="分类于 容器">容器</a>
</div>

    <span><a href="/computer-science/container/Docker/docker/" title="docker笔记">docker笔记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机">计算机</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/" title="分类于 教程">教程</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/note/theme-shoka-doc/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a>
</div>

    <span><a href="/computer-science/note/theme-shoka-doc/special/" title="Step.4 主题特殊功能">Step.4 主题特殊功能</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">hahayixiao @ HaHaYiXiao</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'computer-science/container/Docker/docker/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="//cdn.jsdelivr.net/gh/hahayixiao2/hahayixiao2.github.io@latest/js/app.js?v=0.2.5"></script>




</body>
</html>
